### JDK

- Java Development Kit - комплект для разработки
    - компилятор
    - программа для выполнения байт-кода
    - стандартная библиотека Java
    - генератор документации из комментариев к коду
- JDK
    - OpenJDK бесплатный, но доступна последняя сборка без поддержки
    - Oracle - бесплатно, для коммерции платно

### Компилятор javac

- компилятор кода программы в байт-код
- создает файл с расширением .class

### JVM

- Java Virtual Machine
- выполнение построчно байт-кода
- проверяет на наличие ошибок в байт-коде

### Скачать Java

- Разрядность x64: https://corretto.aws/downloads/latest/amazon-corretto-11-x64-windows-jdk.msi.
- Разрядность x86: https://corretto.aws/downloads/latest/amazon-corretto-11-x86-windows-jdk.msi.
- JDK будет находиться здесь:  C:\Program Files\Amazon Corretto\.
- задать переменную JAVA_HOME C:\Program Files\Amazon Corretto\jdk[version]\bin
- добавить путь в PATH C:\Program Files\Amazon Corretto\jdk[version]\bin

- Компиляция
    - один файл # javac -encoding UTF-8 HelloJdk.java
    - несколько файлов # javac -d bin -encoding UTF-8 *.java //bin название папки
- Запуск
    - # java -Dfile.encoding=UTF-8 HelloJdk
    - # java HelloJdk
    - запуск нескольких файлов # java -cp bin test_app.src.service.Main

### JAR

- Java Archive - java архив со всеми файлами, который можно передавать
- внутри JAR есть специальный текстовый файл с описанием структуры архива — файл манифеста MANIFEST.MF
    - генерируется автоматически при создании java-архива и находится по адресу META-INF/MANIFEST.MF
- перевести все файлы в байт-код, далее
    - # jar cfe <имя jar-файла> <имя стартового класса> <список файлов>
    - # jar cfe library.jar Practicum -C bin .
        - # Точка в конце строки указывает на то, что в JAR должны попасть все файлы из папки bin.
    - c (от англ. create, «создавать») указывает на то, что создаётся новый файл;
    - f (от англ. filename, «имя файла») предупреждает, что после него будет написано имя создаваемого jar-файла;
    - e (от англ. entrypoint, «точка входа») указывает на название класса, с которого нужно начать выполнение программы.
- несколько файлов test_app.src/Main.class и другие
    - создать файл MANIFEST.MF в bin - Main-Class: test_app.src.screenshot.Main
    - перейти в папку bin
        - jar cvf test.jar *
- когда есть файл jar можно запустить
    - # java -jar library.jar

### Упаковка в исполняемый файл exe

- Launch4j - использует jar архив

### Поэтапно компиляция

- структура src.screen.Main.java
- создаем MANIFEST.MF можно внутрь пакета для отдельного приложения либо в корень если один сервис
    - Main-Class: src.screen.Main
- из корня компилируем
    - javac -d bin src/screen/Main.java
- создаем jar из корня
    - jar cfm myapp.jar .\src\screen\MANIFEST.MF -C bin .
- запускаем проверяем
    - java -jar myapp.jar

### Примитивы

- Целочисленные
    - byte - 8бит - от -128 до 127
    - short - 16бит - от -32768 до 32767
    - int - 32бит - от -2 147 483 648 до 2 147 483 647 // используется в основном
    - long - 64бит - 18 нулей, обязательно указывать 123123L
- Дробные
    - float - 32бит - от -3.4*10^-38 до 3.4*10^38 // float number = 4.7E-23;
    - double - 64бит от -4.9*10^-324 до 4.9*10^308 // используется в основном
- Символьный
    - char - 16бит - одинарные кавычки
- Логический
    - boolean - true/false

### Значения по умолчанию

- если вывести незаданное поле класса будет ошибка
    - можно ошибиться когда инициализация по умолчанию задала null, а мы не задавали
- Целочисленные - 0
- Дробные - 0.0
- Логические - false
- Ссылочные (классы) - null
- char - \u0000

### Приведение типов

- при передачах аргумента типа, который входит в диапазон типа параметра, происходит автоматическое (неявное) приведение
  типа
    - byte передать в метод, где int - будет приведение
    - short -> long, float -> double
        - Long bigNum = 10L;
        - short smallNum = bigNum.shortValue()
- явное приведение
    - нельзя тип с большим диапазоном привести к меньшему - int -> byte Ошибка
    - можно самостоятельно привести (byte)integerValue - явное приведение
    - НО! если при явном приведении, значение больше чем диапазон меньшего, будет непредсказуемый результат
    - дробное можно к целочисленному, останется только целая часть

### Классы обертки

- "старшие братья" примитивов
- хранят ссылку, не имеют фиксированного размера, возвращают null, имеют свои методы
    - byte - Byte
    - short - Short
    - int - Integer
    - long - Long
    - float - Float
    - double - Double
    - char - Character
    - boolean - Boolean
- упаковка примитива автоматическая - boxing

```
  int primitive = 7;
  Integer wrapper = primitive;
  
  byte primitive = 3;
  method(primitive);
  
  ...    methjd(Byte num){}
    
    int a = 15;
    int b = 3;
    int c = -7;
    Integer[] numbers = new Integer[3];
    
    numbers[0] = a;
    numbers[1] = b;
    numbers[2] = c; 
    
```

- обратная распаковка типа - unboxing
- но если в классе обертке null, распаковка даст ошибку

```
  Boolean wrapper = true; // упаковали значение в класс-обёртку Boolean
  boolean primitive = wrapper; // распаковали обратно в примитив boolean

    // ошибка
    Float wrapper = null;
    float primitive = wrapper;
    System.out.println(primitive);
```

### Парсинг

- все, кроме Character, имеют метод, позволяющий преобразовывать строки в свой тип
- Числовые (кроме Byte, Short для них делать приведение типа) обертки имеют встроенные методы типа max, min, sum,

### Память Java

- СТЕК
    - жестко выделенная память
    - переменные примитивов хранятся в стеке
    - когда начинает выполнятся Метод, в стеке создается новый блок - фрейм стека, все переменные внутри стека, будут
      созданы
      внутри этого блока стека. При завершении метода, все переменные не доступны
    - поэтому когда мы передаем примитивы как аргументы они копируются в блок стека, все изменения переменных остается
      внутри блока
- КУЧА
    - динамическая память
    - хранятся объекты
    - классы передаются по ссылке, то есть при изменении внутри метода изменится значения в самом классе

### Приведение в арифметических выражениях

- если в double сохранить int1 / int2 - будет х.0, дробная часть будет 0!!
    - если хотя бы один операнд будет double, будет автоматическое приведение к double деления(то же самое, при
      сложении, вычитании и т.д.)

### Порядок вычислений

- Первыми отработают операторы префиксного инкремента и декремента — ++a и --a;
- Затем — операторы умножения, деления и остатка от деления: *, / и %;
- Третьи на очереди — операторы сложения и вычитания + и -;
- Последними выполняются операции с постфиксным инкрементом и декрементом: a++ и a--.

### Порядок логических операций

- Сначала всегда выполняется отрицание !.
- Логическое умножение предшествует сложению — поэтому логическое И && в приоритете.
- Логическое ИЛИ || при наличии других операций выполняется последним.

### Пакеты

- по сути это папка - namespace - пространство имен с файлами классов
- можно импортировать весь пакет, когда много классов import java.util.*;

### Списки & массивы

- java.util.ArrayList - список, хранит только Классы
- ArrayList<String> names = new ArrayList<>();
    - add, get - по несуществующему индексу вызовет исключение
    - add(E e) - добавить элемент, можно передать примитив (упаковка автоматическая)
        - add( int index, E e ) - если использовать index можно вставить в определенное место
    - get(int index) - получить по индексу
    - size() - размер
    - remove(int index)(Object o) - удаление по индексу либо по значению
    - clear() - очистить весь список
    - isEmpty() - пустой или нет
    - contains(E e) - возвращает Boolean, проверяет содержит или нет значение
- массив может хранить примитивы, ссылочные типы
    - length - всегда одно и тоже, так как задается длина при объявлении

### Хеш Таблицы

- он же словарь или ассоциативный массив (мапа, таблица)
- отображение сопоставление каждому объекту первого множества ровно один объект второго
- java.util.HashMap - вместо индекса используется ключ
- HashMap<String, Integer> ages = new HashMap<>();
    - O(1) - поиск по значению, добавление, обновление, удаление
    - не может быть два одинаковых ключа
    - ключи без определенного порядка
    - ключ может быть: число, символ, строка, объект
        - !обязательно переопределить hashCode(), equals()
    - если нет ключа вернёт Null
    - put(K key, V value) - вставка
    - values() - получение массива значений
    - keySet() - получение массива ключей
    - remove(Object key) - удаление по ключу
    - clear() - полностью очистка
    - containsKey(Object key) - проверка по ключу, вернет Boolean
    - containsValue(Object value) - проверка по значению, вернет Boolean
- интерфейс Map - родитель для всех хеш-таблиц
    - put(K key, V value) - вставка (запись), если есть перезапишет
    - containsKey(Object key) - содержит ключ или нет
    - containsValue(Object value) - содержит значение или нет
    - get(Object value) - содержит значение или нет (вернет null)
    - getOrDefault(Object key, V defaultValue) - если ключа нет, вернет значение по умолчанию
    - size() - размер по ключам
    - isEmpty() - пустой или нет
    - remove(Object key), clear() - удаление по ключу (возвращает значение или null)
    - keySet(), values(), entrySet() - итерирует по ключам, значениям, ключ+значение
  ```
    Map<String, String> countriesAndContinents = new HashMap<>();

    countriesAndContinents.put("Марокко", "Африка");
    countriesAndContinents.put("Танзания", "Африка");
    
    for (Map.Entry<String, String> el : countriesAndContinents.entrySet()) {
        System.out.println(el.getKey());
        System.out.println(el.getValue());
    }
  ```
    - интерфейсы
        - представляют дополнительные операции, если ключи хранятся в отсортированном виде
            - SortedMap
            - NavigableMap
    - классы
        - TreeMap
            - наследуется от NavigableMap <-- SortedMap
            - O(log n) - базовые операции, медленнее чем HashMap, так как внутри структура дерева
            - public TreeMap() - новая пустая хеш-таблица, без пустых ячеек
            - public TreeMap(Comparator <? super K> comparator) - передается компаратор - правила сравнения ключей
            - public TreeMap(Map<? extends K, ? extends V> m) - заполняет данными из переданной хеш-таблицы любого типа
            - public TreeMap(SortedMap<K, ? extends V> m)- заполняет данными из переданной хеш-таблицы, но типа
              SortedMap
            ```
                   // можно реализовать несколько вариантов Сортировки
                   Comparator<User> userComparator = new Comparator<>() {
                     @Override
                     public int compare(User user1, User user2) {
                       return user1.userId - user2.userId;
                     }
                   };

                   Map<User, String> users = new TreeMap<>(userComparator);
          
                    // интерфейс Comparable, когда Один способ сортировки
                     class User implements Comparable<User> {
                       public Integer userId;
                       public String username;
                        // ... и другие поля пользователя

                     @Override
                     public int compareTo(User o) {
                      return this.userId - o.userId;
                     }
                      }
            ```
            - методы
                - firstEntry(), firstKey() - первая запись по порядку (ключ-значение, ключ)
                - lastEntry(), lastKey() - последние данные
                - pollFirstEntry(), pollLastEntry() - возвращает данные и удаляет из таблицы
                - lowerEntry(K key), higherEntry(K key) - соседние данные
- LinkedHashMap
    - O(1) - поиск по значению, добавление, обновление, удаление,
        - но чуть медленнее, так как хранить двусвязный список

    - ключи хранятся в том порядке, в каком добавляются
        - 2 способа
            - в порядке добавления записей - первая первой, последняя последней
            - в порядке доступа к записям - при итерации первой будет, к которой дольше всего не обращались,
                - первой к которой было последнее обращение
    - наследуется от HashMap
    - конструктор создает новую хеш-таблицу со стандартными настройками
        - 16 пустых ячеек
        - коэффициент заполнения 75%
        - ключи будут отсортированы в порядке добавления
        - public LinkedHashMap(Map<? extends K, ? extends V> m)
            - заполняет данными из параметра m, создает идентичную копию переданной хеш-таблицы
        - public LinkedHashMap(int initialCapacity)
            - создает объект, в таблице сразу создано переданное количество ячеек
        - public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
            - какой тип сортировки ключей, accessOder == true - в порядке доступа, false - в порядке добавления
              записей (по умолчанию)
            -

### Коэффициент заполняемости HashMap

- по умолчанию 75%
- можно задать
    - public HashMap(int initialCapacity, float loadFactor)
    - loadFactor = 0.6 -> 60%

### Object

- методы
    - для генерации используем Generate-> equals hashCode -> next тех полей которые нужно
    - для генерации toString используем Generate-> etoString -> тех полей которые нужно
    - equals(Object) - возвращает результат проверки объектов на равенство, Используется
        - == - не подходит, так как используется только для примитивов,
        - для корректного сравнения нужно переопределить equals()
        - Необходимо переопределять!!!
        ```
          // по умолчанию
          public boolean equals(Object obj) {
            return (this == obj);
          }
      
          // корректное переопределение 
          class Book {
            public String title;
            public String author;
            public int pagesNumber;
          
            public Book(String title, String author, int pagesNumber) {
            this.title = title;
            this.author = author;
            this.pagesNumber = pagesNumber;
            }
          
            @Override
            public boolean equals(Object obj) {
            if (this == obj) return true; // проверяем адреса объектов
            if (obj == null) return false; // проверяем ссылку на null
            if (this.getClass() != obj.getClass()) return false; // сравниваем классы объектов
          
                  Book otherBook = (Book) obj; // привели второй объект к классу Book
          
                  return Objects.equals(title, otherBook.title) && // проверяем все поля
                          Objects.equals(author, otherBook.author) && // нужно логическое «и»
                          (pagesNumber == otherBook.pagesNumber); // примитивы сравниваем через ==
          
            }
          }
        ```
    - hashCode() - возвращает хеш-код объекта, Используется
        - Необходимо переопределять!!!
        - Базовая реализация метода hashCode() стремится создать уникальный хеш для каждого объекта, в том числе для
          идентичных
        - У всех стандартных ссылочных типов данных в Java (String, Integer, Double и т. д.) методы equals(Object) и
          hashCode() уже корректно переопределены
          ```
               @Override
               public int hashCode() {
                    int hash = 17;
                    if (firstName != null) {
                    // вычисляем хеш первого поля и добавляем к нему начальное значение
                      hash = hash + firstName.hashCode();
                    }
                    hash = hash * 31; // умножаем промежуточный результат на простое число

                    if (lastName != null) {
                    // вычисляем хеш второго поля и добавляем его к общему результату
                    hash = hash + lastName.hashCode();
                      }
                    return hash; // возвращаем итоговый хеш
               }
          ```
        - Три правила переопределения (контракт)
            - Если при сравнении методом equals(Object) объекты оказались равны, то hashCode() должен возвращать у
              каждого из них одно и то же число
            - метод hashCode() должен возвращать одно и то же целое число до тех пор, пока значения полей, используемых
              в методе equals(Object) того же класса, остаются прежними
            - Нужно стремиться к тому, чтобы у объектов, которые не равны при сравнении equals(Object), были разные
              хеш-коды, но учитывать, что они могут совпасть.
                - Поэтому, если у двух объектов одинаковые хеш-коды, нельзя утверждать, что объекты равны. Точный
                  результат покажет только метод equals(Object).
    - getClass() - возвращает класс объекта
    - toString() - строковое представление объекта, Используется
        - Необходимо переопределять!!!
        - только чтение, Не менять состояние объекта
        - В реализацию toString() стоит включать только те поля, которые содержат ключевую или определяющую информацию.
        - Статические или вспомогательные поля можно опустить.
        - Некоторые поля могут содержать объёмные данные. Нет практического смысла в том, чтобы выводить их полное или
          даже сокращённое содержание.
        - Можно отобразить их длину
        - В отдельном форматировании могут также нуждаться такие данные, как даты
        - println(Object) - выведет toString класса
        - соблюдать единй формат
            ```
              @Override // переопределяем toString
              public String toString() {
                return "Person{" + // имя класса
                       "firstName='" + firstName + '\'' + // поле1=значение1
                       ", lastName='" + lastName + // поле2=значение2
                       '}';
              }
            ```
    - clone() - копия объекта
    - wait(lon timeoutMillis) - освобождает монитор и переводит вызывающий поток в ожидание (параметр timeout не
      обязательный)
    - notify(), notifyAll() - возобновляет работу потока (потоков)

### Code style

- в стандарте оформления кода формулируются соглашения по следующим пунктам:
- максимальная длина строки,
- отступы,
- табуляция,
- пустые строки,
- скобки,
- пробелы внутри выражений и инструкций,
- стиль комментариев,
- принципы именования классов, переменных, методов и проч.
- Длина строки в коде должна быть не более 120 символов.
    - Перенос строки должен выполняться после запятой.
    -
        + / : . - на новую строку
  ```
  Плохо
    int period, action; 
    // На одной строке объявлено несколько переменных.
  
  Хорошо
    int period;
    int action;
    // Каждая переменная объявлена на отдельной строке
  ```

### Live Templates

- psvm - метод main
- sout — разворачивается в инструкцию System.out.println();.
- soutm — выводит в консоль имя текущего класса и метода. Например, System.out.println("LiveTemplates.main");.
- soutp — выводит в консоль аргументы метода. Например, System.out.println("args = " + Arrays.deepToString(args));.
- soutv — эта команда похожа на предыдущую, она выводит в консоль значение переменной в формате System.out.println("
  имяПеременной = " + имяПеременной);.
- ifn — создаст конструкцию if для поверки переменной на равенство null
- fori — создаст заготовку для цикла for с переменной i в качестве счётчика
- iter — создаст заготовку для цикла по массиву или списку.

### README.md

- Название проекта и его краткое описание: кем он создан, для чего, какие решает задачи и какие закрывает проблемы.
- Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
- Документация проекта — инструкция о том, как его запустить или протестировать. Здесь же можно найти системные
  требования: версия языка, необходимые расширения.
- Планы проекта, если они есть.

### Модификаторы доступа

- static - для класса, метода или переменной
    - для переменной - она будет привязана к самому класса, независимо от экземпляров,
        - если изменить, изменить для всех экземпляров
        - обращение через Имя класса
    - для метода - применение для утилитарных задач, метода которые не меняют состояние объекта
        - статический метод может обращаться только к статическим методам или переменным
        - Переопределять static (@Override) Нельзя
        - Если сохранить класс наследник как тип Родителя, то будут использоваться методы родителя, а не наследника
    - this, super - запрещены в static - методах!!
    - static import - обращение напрямую к переменным класса, не через класс
        - import static java.lang.Math.PI;
        - double area = PI * (radius * radius);
        - Лучше использовать это редко, будет нечитабельный код
- final - для всего, что нельзя менять, типа readonly TS
    - если примитив, то менять нельзя
    - если объект, менять нельзя, а менять состояние объекта можно
    - переменная на уровне класса Обязательно должна быть проинициализирована
        - либо в теле конструктора
    - для метода защищает от переопределения
    - для private метода не нужно final
    - для класса используется final, чтобы запретить наследование
        - все методы автоматически становятся final
- константы
    - это статическое финальное поле, изменить нельзя никак
    - обязательная инициализация
    - стиль SCREAMING_SNAKE_CASE
- Enum
    - по сути своей static final
    - с большой буквы - public enum DayOfWeek {}
    - new не нужен при инициализации FilmGenre genre = FilmGenre.COMEDY;
    - методы:
        - equals() - сравнение как объекта, можно и ==, аккуратно enum может быть null
        - values() - массив значений
        - valueOf( String name) - возвращает значение если нашел, ошибка если нет
        - часто используется с switch
        - @Override toString() - можно переписать
      ```
        @Override
        public String toString() {
         return name().charAt(0) + name().substring(1).toLowerCase();
        }
      ```

### Абстракция

- доступны только методы, описывающие основное поведение, остальные детали скрыти
    - основной инструмент инкапсуляция
- абстрактный класс - у него не может быть экземпляров, только шаблон
    - может быть конструктор, поля, методы
    - абстрактные методы без реализации (заготовка)
        - public abstract void move();
        - @Override при инициализации метода в наследнике
    - но в абстрактном классе, могут быть обычные методы с реализацией
    - абстрактный класс не может быть пустым

### Интерфейсы

- наследоваться от класса можно только от одного класса
- Абстрактные классы нужны для того, чтобы у всех классов-наследников создавать и поддерживать общую структуру
- Интерфейсы нужны для добавления в класс-реализацию определённой функциональности
- интерфейсы не привязаны к определенному классу
- названия с большой буквы и суффикса -able (Iterable)
- класс либо должен объявить все методы интерфейса (@Override) либо объявить себя абстрактным
- все переменные будут константы
- модификаторы доступа для методов интерфейсов не нужно (публичные по умолчанию)
- расширение от интерфейса через implements
- класс может реализовать сразу Несколько интерфейсов
- интерфейс может расширяться от другого интерфейса (extends)

### Полиморфизм

- многообразный - способность принимать разные формы
- позволяет работать с объектами, имеющие одинаковый интерфейс, при этом не зная о конкретном типе объекта
- сохранять объект наследника в переменную с родительским типом
- позволяет программе взаимодействовать с объектами разных типов одинаково, если у них общий предок или интерфейс
- Классический
    - можем работать с типом который присвоили объекту
        - если несколько интерфейсов реализовано, то доступны будут только те методы, которые есть у этого типа
    - основан на расширении от родительского класса, то есть наследники связаны родительским типом
- Ad-hoc полиморфизм
    - динамический - основан на переопределении метода в наследуемых классах, метод будет вызван их того типа объекта,
      через который создали
        - в отличии от классического, расширение от интерфейса, нет необходимости наследования, более гибкий
    - статический - перегрузка методов
- Параметрический
    - поведение класса или метода, у которых все равно какой типа данные (Дженерики как TS)
    - дженерики можно использовать в интерфейсах
  ```
    public class Pair {
    public final Object key;
    public final Object value;

    public Pair(Object key, Object value) {
        this.key = key;
        this.value = value;
    }

    public void print() {
        System.out.printf("(%s, %s)", key, value);
    }

    public Object getKey() {
        return key;
    }

    public Object getValue() {
        return value;
    }

  ```

### Приведение ссылочных типов

- методы наследуемого объекта не будут доступны из родительского типа
- для получения наследуемых метод надо явно объявить объект с типом наследника
  ```
        Document document = new RussianPassport("1111", "567899");
        RussianPassport passport = (RussianPassport) document;
  ```
- при компиляции не будет ошибки, если наследника попробовать явно привести другого наследника
    - только при выполнении программы
- instanceof - проверка типа
- ограничения для дженериков <T extends Number>, передаваемый дженерик должен быть каким либо числом

```
     interface Document {}
     class RussianPassport implements Document {}
     class Snils implements Document {}
     Document document2 = new Snils("12345678901");
     
     RussianPassport passport = (RussianPassport) document2; // ОШИБКААААА
     
     // можно проверить
     boolean isPassport = document instanceof RussianPassport;
```

### Алгоритмы

- Асимптотическая сложность - количество операций, выполняемых алгоритмом
    - O(n) - линейный - растет линейно
    - O(log(n)) - логарифмический - двоичный логарифм
    - O(1) - константный - постоянный
    - O(n^2) - квадратная

### Сортировка

- слиянием - O(n * log(n)), n - памяти, устойчивая, может поддерживать сортировку по нескольким параметрам
- быстрая - O(n * log(n)) - память не требуется, неустойчивая
- вставками (insertion sort) O(n^2) - используется на маленьких объемах данных
    - разделяет массив на две части: отсортированную и не отсортированную
    - в начале в отсортированной части 0 элементов
    - на каждом шаге рассматриваем очередной элемент и пытаемся вставить в правильное место
- поразрядная - O(n) но только при определенных условиях
    - подсчитывает количество вхождений, а затем выводит в определенном порядке столько раз, сколько встречались
    - заранее известен диапазон сортируемых значений

### Структуры данных

- это совокупность трех компонентов:
    - набор данных
    - отношение между ними
    - все методы по управлению этими данными
- в Java за это отвечают коллекции - Java Collections Framework

### Иерархия коллекций

- Вершина первой части - интерфейс Iterable<T>
    - представляет инструменты для обхода, перебора слева направо
    - помимо forEach, можно воспользоваться Итератором
        - hasNext(), next()
    - прямой наследник интерфейс Collection<T>, его наследуют три интерфейса:
        - Set<T> - каждый элемент уникален
        - Queue<T> - элементы располагаются один за другим согласно очереди - FIFO
        - List<T> - создание списков, элементы могут повторяться, произвольный порядок, могут расширяться, сортировка
            - LinkedList<T> - двунаправленный связный список
                - наследуется от AbstractSequentialList<T> последовательный обход элементов друг за другом.
                - операции могут применяться с начала или конца
                - addFirst(), addLast() - добавляет в начало, конец
                - getFirst(), getLast() - получить первый, последний
                - removeFirst(), removeLast() - удаляет из начала, конца
                - add(int, T), remove(int), get(int) - операции по индексу
                - size() - размер
            - ArrayList<T> - основан на массиве список
                - динамический массив
                - два параметра:
                    - размер
                    - вместимость - число элементов, потенциально могут храниться, по умолчанию 10
                        - увеличивается на 50% после вместимость == размер
                - не только реализует List<T>, но и AbstractList<T>
                    - AbstractList<T> реализует List<T>
            - методы List<T>:
                - add(E e), add(int index, E e) - index индекс позиции вставки
                - get(int index) - получение по индексу
                - set(int index, E e ) - замена элемента по индексу
                - remove(E e), remove(int index) - удаление по элементу, по индексу
            - два способа преобразования массива или набора случайных чисел:
                - Arrays.asList(...) - можно создать и заполнить небольшой список одним выражением
                ```
                   String[] citiesArray = {"Воронеж", "Южно-Сахалинск", "Иркутск"};

                   List<String> cities = Arrays.asList(citiesArray);

                    System.out.println(cities); // [Воронеж, Южно-Сахалинск, Иркутск]
                ```
                - List.of(...)
                ```
                    String[] citiesArray = {"Воронеж", "Южно-Сахалинск", "Иркутск"};

                    List<String> cities = List.of(citiesArray);

                    System.out.println(cities);
                ```
                - при таком преобразовании, списки неизменяемы, не поддерживают удаление, добавление
        - методы Collection<T>:
            - add(E e) - добавление
            - contains(Object o) - проверка наличия
            - remove(Object o) - удаление
            - size() - количество элементов
            - isEmpty() - есть ли в коллекции элементы
            - поддерживает System.out.println(collection)
            - add | contains | remove All - добавление, проверка наличия, удаления сразу несколько
              ```
                Collection<String> colors = new ArrayList<>();
                Collection<String> colorsAdditional = new ArrayList<>();
              
                colors.addAll(colorsAdditional);
              ```
            - clear() - очистка
            - toArray() - трансформация в массив
- Вершина второй части - интерфейс Map<K, V> - ключ со значением типа V
    - задает однозначную одностороннюю связь
    - наследник HashMap<K,V>

### Comparator

- сравнение Comparator<T>
- помогает при сортировке сложных объектов
- добавляет метод int compare(T, T) - необходимо переопределить
- для лексикографической сортировки слов без учёта регистра
    - return String.CASE_INSENSITIVE_ORDER.compare(item1.name, item2.name);
- Классы-обёртки, такие, как Integer или Double
    - return Integer.compare(item1.price, item2.price);

```
class Item {

    public final String name; // название товара
    public final int price; // цена
    public final int popularity; // популярность

    public Item(String name, int price, int popularity) {
        this.name = name;
        this.price = price;
        this.popularity = popularity;
    }

    // сразу переопределим toString(), чтобы потом выводить содержание списка
    @Override
    public String toString() {
        return "Item{" +
                "name='" + name + '\'' +
                ", price=" + price +
                ", popularity=" + popularity +
                '}';
    }
}


class CompareItem implements Comparator<Item> {
    @Override
    public int compare(Item item1, Item item2) {
//        // сравниваем товары — более дорогой должен быть дальше в списке
//        if (item1.price > item2.price) {
//            return 1;
//
//            // более дешёвый — ближе к началу списка
//        } else if (item1.price < item2.price) {
//            return -1;
//
//            // если стоимость равна, нужно вернуть 0
//        } else {
//            return 0;
//        }

        return item1.price - item2.price;
    }
}

public class CompareTest {
    public static void main(String[] args) {
        // создаём список товаров
        List<Item> items = new ArrayList<>();
        items.add(new Item("Рубашка", 4500, 37));
        items.add(new Item("Носки", 55, 8));
        items.add(new Item("Толстовка", 1399, 74));
        items.add(new Item("Носки", 169, 19));

        System.out.println("До сортировки:");
        System.out.println(items);

        CompareItem compareItem = new CompareItem();
        items.sort(compareItem);

        System.out.println("После сортировки:");
        System.out.println(items);
    }
}
```

- метод reversed() - разворачивание

```
CompareItem compareItem = new CompareItem();
items.sort(compareItem);

System.out.println("После сортировки:");
System.out.println(items);

Comparator<Item> reversedComparator = compareItem.reversed();

items.sort(reversedComparator);
System.out.println(items);
```

### Класс помощник Collections

- утилитарный класс
- задача упрощения работы с другими классами
- методы
    - emptyList() - создает пустой список
    - singletonList(T) - создает список из единственного элемента
    - nCopies(int, T) - создает список, где элемент повторен n раз
    - при этом эти списки Неизменяемы!!
    - fill(List<T>, T) - заменить все значения один значением
    - copy(List<T>, List<T>) - копирование (замена) из второго в первый
        - список куда копируется должен быть по размеру не меньше копируемого
    - sort(List<T>, Comparator<T>) - сортировка
    - min | max (Collection<T>)

```
    final List<String> emptyList = Collections.emptyList();
    final List<String> singletonList = Collections.singletonList("Привет, мир!");
    final List<String> nCopiesList = Collections.nCopies(5, "Java");
    
    ArrayList<String> fruits = new ArrayList<>();
    fruits.add("Банан");
    fruits.add("Апельсин");
    fruits.add("Яблоко");
    fruits.add("Груша");

    System.out.println(fruits);

    Collections.sort(fruits, String.CASE_INSENSITIVE_ORDER);

    System.out.println(fruits);
```

## Множество Set

- набор уникальных данных!! но хаотичны, не сохраняет порядок объектов
- проверка на наличие элемента O(1)
- наследуется от Collection
- работает быстрее других, применяется часто
- элементы не упорядочены
- его наследники
    - SortedSet -> NavigableSet -> TreeSet
    - AbstractSet
        - TreeSet
        - HashSet -> LinkedHashSet
- методы
    - add (E e) - возвращает true если сохранился, false - еси существует, при этом не сохранит
    - addAll(Collection <? extends E> c) - добавить список или множество, при этом если хотя бы один содержится вернет
      False
    - contains(Object o) - имеется или нет
    - remove(Object o ) - удаление объекта
    - isEmpty(), size()
- конструкторы
    - public HashSet()
        - пустое множество без параметров
    - public HashSet(Collection<? extends E> c)
        - создает множество из списка или множества
        - останутся только уникальные
    - public HashSet(int initialCapacity, float loadFactor)
        - количество созданных ячеек и коэффициент заполнения
- LinkedHashSet
    - сохраняет порядок добавленных объектов
    - аналогичен LinkedHashMap
    - O(1) - базовые операции
- TreeSet
    - аналогичен TreeMap
    - O(log n) - базовые операции

### Деревья

- способ представить информацию в виде иерархической структуры, где элементы ниже по иерархии, зависят от выше

### String

- строки, созданные не через литерал, не попадут в один и тот же пул, и не будут ==, сравнение new String через
  String.equals()
- методы
    - length(), isEmpty()
    - trim() - удаляет пробелы в начале и в конце (не меняет исходное)
    - toUpperCase(), toLowCase() - изменение регистра
    - charAt(int index) - получить символ по индексу
    - startWish(), endsWish() - начинается, заканчивается
    - contains() - содержит
    - substring(int beginIndex), substring(int beginIndex, int endIndex) - получить подстроку под индексам
        - endIndex - исключается
    - split(String regex) - из строки в массив строк
        - regex - для спец символов необходимо \\ - "\\*"
            - <(>,   <)>, <[>, <{>, <.>, <?>, <*>, <+>,  <|>, <^>, <\>.
- из массива в строку
    - String.join(String delimiter, String... strs)
    ```
        String[] arrayOfPets = new String[]{
                "Кот Батончик",
                "Хомяк Рафаэлка",
                "Попугай Картошка"
        };

        String str = String.join(", ", arrayOfPets);
    ```
    - этим же методом можно создать строку из нескольких строк
        ```
          String cat = "Кот Батончик";
          String pet = "Хомяк Рафаэлка";
          String ara = "Попугай Картошка";

          String str = String.join(", ", cat, pet, ara);  
        ```

- substring - непрерывный набор символов внутри строки
- Замена строк (похоже как в JS)
    - replace(String target, String replacement), replaceFirst(String target, String replacement)
        - replaceFirst заменит только первое вхождение

### StringBuilder

- позволяет менять содержание строки без создания новой
- методы
    - append(String str), append(String str)- вставка в конец
    - toString() - привести к обычной строке
    - методы String - indexOf(), lastIndex(), substring(),replace() - такие же
    - insert(int index, String str) - вставка по индексу
    - deleteCharAt(int index), delete(int startIndexInclusive, int endIndexExclusive)
        - удаление одного или нескольких элементов
    - reverse() - развернуть
    - setLength(int newLength) - обрезка с начала

### Форматирование строк

- похоже как Python Шаблоны
- оформленное отображение строк
- String.format(String format, Object... args) - format - образец, столько же аргументов сколько в образце

```
  String[] colors = new String[]{"красный", "жёлтый", "зелёный"};
  String trafficLight = String.format("Цвета светофора: %s, %s и %s.", colors[0], colors[1], colors[2]);
  System.out.println(trafficLight);

  // либо сразу вывести через printf
  System.out.printf("Цвета светофора: %s, %s и %s.", colors[0], colors[1], colors[2]);
```

- символы преобразования
    - %s — для строк (s — сокращение от string);
        - %S, %b и т.д. — для строк поднять регистр;
    - %d — для целых чисел (d от decimal);
    - %f — для чисел с плавающей точкой (f от float);
    - %b — для булевых значений (b от boolean);
    - %c — для символов (c от char и сharacter).
    - можно привести к типу - System.out.printf("%b", "Hello, Java!"); // получим true
    - \n - перенос строки
- параметры для преобразования
    - %55s - добавит 55 символов перед переменной
    - %-55s - добавит 55 символов после переменной
    - %1.12s - до точки перед, после точки после

### Иерархия исключений

- Все исключения наследуют от одного класса — Throwable
- checked - проверяемые, исключения, обработка которых обязательна и является частью логики приложения
    - Если не настроить обработку проверяемых исключений, то программа не скомпилируется
    - исключение должно быть «отловлено или объявлено выброшенным»
- подклассы
    - Error (unchecked)
        - VirtualMachineError - Базовые ошибки JVM, связанные с тем, что исчерпаны ресурсы или обнаружены повреждения.
        - OutOfMemoryError - Производный класс от VirtualMachineError, который показывает ошибки из-за нехватки памяти.
        - StackOverflowError - Производный класс от VirtualMachineError, показывает переполнение стека из-за того, что
          метод слишком много раз вызывал сам себя.
        - AssertionError - Ошибка утверждения.
        - IOError - Исключение, которое происходит при серьёзных ошибках ввода-вывода.
        - ThreadDeath - Возникает при вызове метода Thread.stop() у потока.
    - Exception (checked)
        - RuntimeException (unchecked)
            - ArithmeticException - Исключения при арифметических операциях, например деление на 0.
            - IllegalArgumentException - Возникает при неверно переданных в метод или конструктор параметрах.
            - IndexOutOfBoundsException - Исключение при выходе за заданный диапазон.
            - NoSuchElementException - Данного элемента больше не существует в перечислении.
            - NullPointerException - Приложение пытается использовать null в том месте, где требуется инициализированный
              объект.
            - UnsupportedOperationException - Операция не поддерживается вызываемым объектом.
            - ClassCastException - Невозможность привести объект к заданному типу.
        - Other Exception (checked)
            - IOException - Это базовый класс проверяемых исключений ввода-вывода.
            - EOFException - Исключение, которое сигнализирует о внезапном достижении конца файла или потока.
            - FileNotFoundException - Файл по указанному пути не существует.
            - FileSystemException - Базовый класс для исключений файловой системы, таких как ошибка доступа, попытка
              создать уже существующий файл или удалить не пустую директорию.
            - MalformedURLException - Неверный синтаксис при создании класса ссылки из строки.
            - SocketException - Ошибки при создании/обрыве соединения по сокету.
            - UnknownHostException - Невозможность определить IP-адрес узла по доменному имени.
            - SQLException - Ошибки при работе с базой данных.
            - TimeoutException - Исключение — происходит у методов, у которых ограничено выполнение по времени.
            - URISyntaxException - Неверный формат универсального идентификатора ресурсов.
- Throwable - ловит все, но не понятно какой тип ошибки

```
        try {
            return new URI(input);
        } catch (URISyntaxException exception) {
            System.out.println("Ошибка: неверный синтаксис URI!");
        } catch (NullPointerException exception) {
            // ловим исключение NullPointerException
            System.out.println("Ошибка: передан неинициализированный объект!");
        }
        return null;
```

- при цепочке Важно соблюдать правильную последовательность
    - сначала исключения в классах-наслдениках
    - потом родительские

```
    // правильно
       try {
            return (String) x;
        } catch (ClassCastException e) {
            System.out.println("Некорректное приведение типов");
        } catch (RuntimeException e) {
            System.out.println("Ошибка во время выполнения");
        } catch (Exception e) {
            System.out.println("Произошла неизвестная ошибка");
        }
    // не правильно
        try {
            return (String) x;
        } catch (Exception e) {
            System.out.println("Произошла неизвестная ошибка");
        } catch (RuntimeException e) {
            System.out.println("Ошибка во время выполнения");
        } catch (ClassCastException e) {
            System.out.println("Некорректное приведение типов");
        }
        return null;
```

- можно объединить типы ошибок, если их обработка, например, одинакова

```
        try {
            new ArrayList<String>().add("1");
        } catch (UnsupportedOperationException | IllegalArgumentException exception) {
            System.out.println("Возникла ошибка, свяжитесь с нами!");
        }
```

- посмотреть стек-трейс исключения - exception.printStackTrace(); // будет выведен стек-трейс ошибки
- сообщение об ошибке коротко - exception.getMessage()
    - лучше не использовать, может быть null
- Throwable.getStackTrace() возвращает массив элементов StackTraceElement
    - можно посмотреть имя класса, имя файла, строка кода

```
catch (ArithmeticException exception) {
  for (StackTraceElement stack : exception.getStackTrace()) {
       System.out.println(String.format("Класс: " + stack.getClassName() + ", " +
                    "метод: " + stack.getMethodName() + ", " +
                    "имя файла: " + stack.getFileName() + ", " +
                    "строка кода: " + stack.getLineNumber()));
}}
```

### Свое исключение

- при создании своего класса Исключений от Exception, Можно переопределить 4 конструктора

```
public class InputException extends Exception {
    public InputException() {
    }

    public InputException(final String message) {
        super(message);
    }

    public InputException(final String message, final Throwable cause) {
        super(message, cause);
    }

    public InputException(final Throwable cause) {
        super(cause);
    }
}

final UserInputException userInputException = new UserInputException("Ошибка ввода!");
        try {
            throw userInputException;

        } catch (Throwable e) {
            System.out.println("eeee " + e.getMessage());
        }

```

- в свой клас можно добавлять свои методы

```
public class Main {
    public static void main(String[] args) {
        printRangeInteger("10", 0, 100);
        printRangeInteger("-10", 0, 100);
        printRangeInteger("110", 0, 100);
        printRangeInteger("abc", 0, 100);
    }

    public static void printRangeInteger(final String inputString, final int from, final int to) {
        try {
            final int input = Integer.parseInt(inputString);
            if (input < from) {
                throw new InputException("Введённое число слишком маленькое!", input);
            }
            if (input > to) {
                throw new InputException("Введённое число слишком большое!", input);
            }
            System.out.println(input);
        } catch (NumberFormatException exception) {
            System.out.println("Ошибка ввода - введено не число!");
        } catch (InputException exception) {
            System.out.println(exception.getDetailMessage());
        }
    }
}

class InputException extends Exception {
    private final int inputValue;

    public InputException(final String message, final int inputValue) {
        super(message);
        this.inputValue = inputValue;
    }

    public String getDetailMessage() {
        return getMessage() + " = " + inputValue;
    }
}
```

#### Слово предупреждение throws

- метод или конструктор может сгенерить исключение
    - public void methodWithException() throws FirstException {}
        - этот метод может сгенерировать исключение FirstException
    - можно несколько throws NumberShouldBePositiveException, IncorrectInputStringException

#### Final - обработка исключений

- если catch не будет, то исключение будет выброшено после final
- return  !!лучше НЕ использовать

```
try {
    // действие, которое может вызвать ошибку
} catch (Exception exception) {
    // действие по обработке исключений
} finally {
    // действие, которое должно вызваться всегда
}
```

### Работа с файлами

- java.io.File, доступный с 1-й версии Java (1996);
- более новый API java.nio.file.Path, доступный с 7-й версии Java (2011)
- методы File
    - getName() - имя директории, файла
    - isDirectory(), isFile() - boolean файл или директория
    - list() - возвращает String массив названий файлов и директорий, если нет Null
    - listList() - возвращает File массив, если нет Null
    - mkdir() - создание директории, возвращает boolean
    - renameTo(File dest) - переименовывает файл или директорию, возвращает boolean
    - delete() - удаляет файл или !!пустую директорию, который передан в конструктор, возвращает boolean
- недостатки File
    - нельзя скопировать и переместить файл
    - в основном возвращает boolean, исключения лучше обрабатывать
- с 7 версии добавили новые классы
    - Paths - два метода для получения объекта Path
    - Path - доработанная версия File. Интерфейс
    - Files - много статических методов
- Paths
    - из переданной строки или URI получить объект типа Path
    - get(String first, String... more) - преобразует строку пути или последовательность строк в Path
    - Path testFilePath = Paths.get(HOME, "test", "file.txt");
- Path
    - getFileName() - имя файла из пути
    - getParent(), getRoot() - возвращает родительскую, корневую File
- Files
    - createFile(Path path,FileAttribute<?>... attrs) - создает пустой файл, исключение если существует
        - attrs - необязательный список - доступ, инфо о создателе
    - createDirectory(Path dir, FileAttribute<?>... attrs) - создает директорию
    - move(Path source, Path target, CopyOption. . . options) - перемещает файл,
        - source - откуда
        - target - куда
    - copy(Path source, Path target, CopyOption... options)
        - options
            - REPLACE_EXISTING - если есть заменить
            - COPY_ATTRIBUTES - скопировать аттрибуты оригинального
            - ATOMIC_MOVE - атомарно, перемещение целиком или не выполнится
    - void delete(Path path) - удаляет, исключение если не пустая или не существует!!
    - boolean deleteIfExists(Path path) - удаление если существует

```
private static final String HOME = "E:\\1. Документы\\Edication\\2. Java\\java_edication\\src\\files";

    public static void main(String[] args) {
        Path myFile = Paths.get(HOME, "test.json2");

        Path moveDir = Paths.get(HOME);
        Path targetFile = moveDir.getParent().resolve(myFile.getFileName());

        try {
            Files.copy(myFile, targetFile);
        } catch (IOException e) {
            System.out.println("err " + e);
        }
    }
```

### Потоки вводы-вывода

- тип передаваемых данных
    - символьные потоки - содержат символы
        - текстовые файлы
    - байтовые - информация в виде последовательных байтов
        - видео, pdf, изображения
- классы
    - InputStream - вывод для чтения байтов
    - OutputStream - вывод для записи байтов
    - Reader - ввод для чтения символов
    - Writer - вывод для записи символов
    - PrintStream - стандартный выходной поток
- абстрактные классы
    - FileInputStream, FileOutputStream, FileReader, FileWriter
- общая схема работы
    - создается потоковый объект и ассоциируется с файлом
    - данные читаются из потока или записываются
    - поток закрывается

```
Writer fileWriter = new FileWriter(HOME + "\\" + "test.txt", true);

fileWriter.write("new record\n");
fileWriter.write("add text");

fileWriter.close();

Reader fileReader = new FileReader(HOME + "\\" + "test.txt");

int data = fileReader.read();

while (data != -1) {
    System.out.println((char) data);
    data = fileReader.read();
}

fileReader.close();
```

- Буферизация — способ ввода и вывода данных, при котором для их временного хранения используется область памяти —
  буфер.
    - BufferedReader(Reader in)
    - BufferedReader(Reader in, int sz) - размер буфера

```
FileReader fileReader = new FileReader(HOME + "\\" + "test.txt");
BufferedReader bufferedReader = new BufferedReader(fileReader);

while (bufferedReader.ready()) {
    String line = bufferedReader.readLine();
    System.out.println(line);
}

bufferedReader.close();
```

#### try-with-resources

- close() - используется, чтобы сообщить, что файл больше не нужен
    - но его можно забыть, например, если будет исключение
    - раньше использовалось в finally
- try-with-resources - позволяет закрыть один или несколько ресурсов
    - ресурс, наследуемый от Closeable, AutoCloseable

```
try (Resource1 resource1 = new Resource1(); Resource2 resource2 = new Resource2()) {
            System.out.println("внутри блока try");
        }
        
class Resource1 implements AutoCloseable {

    @Override
    public void close() {
        System.out.println("метод close() для Resource1");
    }
}

class Resource2 implements AutoCloseable {

    @Override
    public void close() {
        System.out.println("метод close() для Resource2");
    }
}
```

### Кодировки

- ASCII ISO 8859 - American Standard Code the Information Interchange
    - американский стандартный код для обмена информацией
- 128 символов
    - первые 32 - невидимые управляемые символы
    - последний DEL - тоже управляющий
    - 32 до 126 - видимые, пробел, знаки препинания, латиница и цифры
- определить символ по его числовому значению
    - System.out.println((char) 89);
- ISO 8859-1 до 8859-15 для разных языков
- Windows 1251, 1252 совместимая с ASCII - с русским языком
- Unicode - юникод - сегодня стандарт, включает иероглифы, арабские вязи, эмодзи
    - разбит на 17 плоскостей по 65 536 значений
    - UTF-8 самый распространенный
    - System.out.println("\u041F\u0440\u0430\u043A\u0442\u0438\u043A\u0443\u043C"); // Практикум
- Java
    - Charset
        - forName(String charsetName) - возвращает объект кодировки по имени
    - StandardCharsets - класс с константами для стандартных наборов символов
    - Кодировка определяется во время запуска
        - System.out.println(Charset.defaultCharset().displayName()); // UTF-8
    - Кодировка по умолчанию — глобальный параметр.
    - Нельзя установить для одних классов или функций одну кодировку, а для других — другую. Кроме того, её нельзя
      изменить в процессе выполнения программы.
    - Но главное, разработчик может использовать функцию, которая будет работать по-разному в разном окружении, и не
      заметить этого.
    - Проблему кодировки по умолчанию решает запуск Java с параметром
        - java -Dfile.encoding=UTF-8 Practicum
    - рекомендуем использовать сигнатуры с указанием кодировки, такие как byte[] getBytes(Charset charset) и String(
      byte[] bytes, String charsetName).
      ```
       // преобразование из строки в массив байтов
       String s = "Обычная строка.";
       byte[] buffer = s.getBytes(StandardCharsets.UTF_8);

       // преобразование из массива байтов в строку
       byte[] buffer = new byte[1000];
       String s = new String(buffer, StandardCharsets.UTF_8);
      ```

### Стримы и операции с ними Stream

- более удобный способ чем циклы для операций как трансформаций и фильтраций
- на основе входного списка объектов создается стрим - специальная последовательность данных и операций, которые будут
  выполняться
- дает декларативно описать, что нужно сделать с каждым элементом
- операции
    - промежуточные
        - задают правила изменения стрима и возвращают трансформированный поток исходных данных
    - терминальные
        - конечные операции, завершает работу над стримом
        - вызывается один раз
    - ленивые вычисления (lazy evaluation)
        - если нет терминальной операции, то и промежуточные не выполняются
- метод collect()
    - терминальная операция
    - преобразовывает в какой-то тип данных

```
public List<String> processFilePaths(List<String> paths) {
        List<String> result = paths
                .stream()
                .filter(filePath -> !filePath.endsWith(".tmp"))
                .map(filePath -> Paths.get(filePath).getFileName().toString())
                .map(fileName -> {
                    if (fileName.startsWith("hide")) {
                        return fileName.replace("hide", "very_secret_file");
                    } else {
                        return fileName;
                    }
                })
                .collect(Collectors.toList());

        return result;
    }
```

### Лямбда-функции

- функции, у которых нет имени и которые не принадлежат
- вместо класса Компаратора для сортировки
- синтаксис (список входных параметров) -> { блок реализации функции};
    - по аналогии с JS, можно без фигурных, либо без входных параметров
    - можно не указывать тип параметра, Java може твывести его сама

```
// объявляем класс, реализующий интерфейс Comparator
class CircleComparator implements Comparator<Circle> {
    @Override
    public int compare(Circle o1, Circle o2) {
        return o1.getRadius() - o2.getRadius();
    }
}
circles.sort(new CircleComparator());

circles.sort((Circle circle1, Circle circle2) -> {
            return circle1.getRadius() - circle2.getRadius();
        });
```

### Механизм замыканий

- изменение значения переменной, используемой в лямбда-функции, может вызвать трудноотлавливаемые логические ошибки
- переданная переменная, и используемая в другом классе, должна быть final
- можно передать ссылочный объект, и менять его поля (НО Осторожно)

```
// fullName будет автоматически final
GreetingGenerator gg = login -> "Приветствуем вас, "
                + fullName
                + " (" + login + ")"
                + "!\n"; 
                
 Map<String, String> fullNames = new HashMap<>();
        fullNames.put("mr_Dark", "Николай");
        fullNames.put("craziest", "Вячеслав Юрьевич");

        //лямбда сохранена в переменную gg и будет использована позже
        GreetingGenerator gg = login -> "Приветствуем вас, "
                + fullNames.get(login)
                + " (" + login + ")"
                + "!\n";


        EmailCreator emailCreator = new EmailCreator(gg);
        System.out.println(emailCreator.createEmail("mr_Dark", "Рады видеть вас в нашем приложении"));

        fullNames.put("mr_Dark", "Николай Сергеевич");
        System.out.println(emailCreator.createEmail("mr_Dark", "Рады видеть вас в нашем приложении"));
```

### Основы функционального программирования

- описывает программу как набор преобразований, аналогичных математическим формулам
- определение функции следуют два важных свойства:
    - Результат работы функции должен зависеть только от её входных аргументов.
    - Функция не должна иметь побочных эффектов.
- функция стремится возвращать одинаковые значения при одинаковых входных аргументах.
    - Это свойство функции называется детерминированностью
- Функции, которые соответствуют обоим критериям — детерминированности и отсутствию побочных эффектов, — называют
  чистыми функциями
- Функции, которые работают с другими функциями — принимают их в качестве аргумента либо возвращают в качестве
  результата,
    - называются функциями высшего порядка

```
public static void main(String[] args) {
        //Попробуйте выбрать другое значение операции из набора "+", "-", "*", "/"
        String operation = "/";
        //получаем лямбда-функцию, реализующую требуемую операцию
        BiFunction<Integer, Integer, Integer> arithmeticOperation = getOperation(operation);
        //Попробуйте изменить аргументы
        int arg1 = 7;
        int arg2 = 3;

        //вызываем полученную лямбда-функцию с заданными аргументами
        int result = arithmeticOperation.apply(arg1, arg2);
        System.out.println(result);
    }

    //функция, которая в зависимости от аргумента возвращает лямбда-функцию, вычисляющую соответствующую операцию
    private static BiFunction<Integer, Integer, Integer> getOperation(String sign) {
        switch (sign) {
            case "+":
                return (value1, value2) -> value1 + value2;
            case "-":
                return (value1, value2) -> value1 - value2;
            case "*":
                return (value1, value2) -> value1 * value2;
            case "/":
                return (value1, value2) -> value1 / value2;
            default:
                throw new IllegalArgumentException("Неизвестная операция");
        }

    }
```

- предпочтение рекурсии вместо циклов, циклы изменяют переменную счетчика
- интерфейсы, где ровно !!Один абстрактный метод, называются функциональными интерфейсами.
    - А сам метод при этом называют функциональным методом.
    - Аннотация @FunctionalInterface не обязательна

```
@FunctionalInterface
interface GreetingGenerator {
    String generateGreeting(String login);
}

GreetingGenerator gg = login -> "Приветствуем вас, "
                + fullName
                + " (" + login + ")"
                + "!\n";
```

```
@FunctionalInterface
interface Summator {
    int sum(int n1, int n2);
}

public class FilesTest {
    public static void main(String[] args) {
        // сохраните лямбду в переменную
        // лямбда должна складывать два целых числа
        Summator summator = (n1, n2) -> n1 + n2;
        // допишите код, использующий лямбду
        System.out.println("Сумма 23 и 65 равна " + summator.sum(23, 65));
    }
}
```

- функциональные интерфейсы стандартной библиотеки (java.util.function)
    - Function<T, R>
        - единственный метод описывается как R apply(T t)
          ```
              Function<Integer, String> intToString = num -> String.valueOf(num);
    
              System.out.println(intToString.apply(1000_0000));
          ```
    - Predicate<T> с методом boolean test(T t);
      ```
        Predicate<Integer> isEven = num -> num % 2 == 0;

        if (isEven.test(12345)) {
            System.out.println("Число чётное");
        } else {
            System.out.println("Число нечётное");
        }
      ```
    - Consumer<T> с методом void accept(T t);
        - интерфейс подойдёт для тех случаев, когда нужно выполнить какие-то действия ради их побочных эффектов
      ```
        Consumer<Double> outputDoubleConsumer =
        num -> System.out.println(String.format("Передано число %.2f", num));

        outputDoubleConsumer.accept(1234.5678);
      ```
    - Supplier<T> с методом T get().
        - не принимает аргументов и возвращает значение типа T
      ```
          Supplier<LocalDateTime> currentDateTimeSupplier = () -> LocalDateTime.now();

          System.out.println("Текущая дата и время: " + currentDateTimeSupplier.get());
      ```
- > В профессиональной литературе названия функциональных интерфейсов используются в сленговом виде — Функция, Предикат,
  Потребитель

### Анонимные классы

- это класс, который, как и лямбда-выражение, не имеет имени и описывается в момент его использования

```
import java.util.HashSet;
import java.util.Set;

public class GreetingEmailManager {

    public static void main(String[] args) {
        String fullName = "Николай";

        //создаём анонимный класс, реализующий интерфейс GreetingGenerator
        GreetingGenerator gg = new GreetingGenerator() {
            //поле с набором всех логинов, с которыми вызывался метод generateGreeting
            Set<String> processedLogins = new HashSet<>();

            @Override
            public String generateGreeting(String login) {
                //вступительная часть приветствия зависит от того,
                //первый раз или нет обрабатывается данный логин
                String introString;
                if (processedLogins.contains(login)) {
                    introString = "Снова приветствуем вас, ";
                } else {
                    introString = "Приветствуем вас, ";
                }
                //добавляем текущий логин к обработанным
                processedLogins.add(login);

                return introString
                        + fullName
                        + " (" + login + ")"
                        + "!\n";
            }
        };

        EmailCreator emailCreator = new EmailCreator(gg);
        System.out.println(emailCreator.createEmail("mr_Dark", "Рады видеть вас в нашем приложении"));
        //второе письмо к пользователю mr_Dark будет содержать новое приветствие
        System.out.println(emailCreator.createEmail("mr_Dark", "Рады видеть вас в нашем приложении"));

    }
}

@FunctionalInterface
interface GreetingGenerator {
    String generateGreeting(String login);
}

class EmailCreator {
    //объект GreetingGenerator используется для генерации приветствия в письме
    private GreetingGenerator greetingCreator;

    public EmailCreator(GreetingGenerator greetingCreator) {
        this.greetingCreator = greetingCreator;
    }

    public String createEmail(String login, String text) {
        return greetingCreator.generateGreeting(login) + text;
    }
}
```

#### Ссылка на метод

- лямбда выражение передаваемой функции
    - как в JS [].map(Boolean)
    - .peek(System.out::println) -> (String name) -> System.out.println(name)
        - String::toUpperCase

```
class Candy {
    final String name;
    final String producer;
    final int price;
    final int amountSold;
    final Set<String> alternateNames;

    public Candy(String name, String producer, int price, int amountSold, Collection<String> alternateNames) {
        this.name = name;
        this.producer = producer;
        this.price = price;
        this.amountSold = amountSold;
        this.alternateNames = Set.copyOf(alternateNames);
    }

    public static int compareByName(Candy c1, Candy c2) {
        return c1.name.compareTo(c2.name);
    }

    public static int compareByPrice(Candy c1, Candy c2) {
        return c1.price - c2.price;
    }

    public void printNameWithPrice() {
        System.out.println(name + ": " + price);
    }

    @Override
    public String toString() {
        return "Candy{" +
                "name='" + name + '\'' +
                ", producer='" + producer + '\'' +
                ", price=" + price +
                ", amountSold=" + amountSold +
                ", alternateNames=" + alternateNames +
                '}';
    }
}

public class FilesTest {
    public static void main(String[] args) {
        Candy candy1 = new Candy("Мишка на севере", "Первая кондитерская фабрика", 28, 4, Set.of("Мишка косолапый", "Мишка"));
        Candy candy2 = new Candy("Мишка в лесу", "Триумф", 32, 2, Set.of("Мишка косолапый"));
        Candy candy3 = new Candy("Трюфель", "Триумф", 44, 5, Set.of("Трюфель классический", "Трюфель шоколадный"));
        Candy candy4 = new Candy("Победа", "Первая кондитерская фабрика", 14, 12, Set.of("ПОБЕДА"));

        Candy[] candies = {candy1, candy2, candy3, candy4};

        System.out.println("Сортировка по имени");
        Arrays.sort(candies, Candy::compareByName);
        Arrays.stream(candies).forEach(Candy::printNameWithPrice);

        System.out.println("Сортировка по цене");
        Arrays.sort(candies, Candy::compareByPrice);
        Arrays.stream(candies).forEach(Candy::printNameWithPrice);
    }
}
```

#### Если метод не может вернуть значение

- тип Optional. Optional<T> — это специальный класс-обёртка, объект которого может содержать значение класса T либо не
  содержать ничего
- статические методы Optional
    - Optional.of - принимает в качестве аргумента значение любого типа (но не NUll)
        - Optional<Integer> optionalNumber = Optional.of(123);
    - Optional.ofNullable - в качестве аргумента значение любого типа, при этом оно может быть равно null
        - когда заранее неизвестно, равно ли оборачиваемое значение null или нет
          ``` 
            String someString = ...; // значение может прийти из другого метода и равняться null
            Optional<String> optionalString = Optional.ofNullable(someString);
          ```
    - Optional.empty - не принимает аргументов и создаёт объект класса Optional
        - когда нужно вернуть Optional без значения
        ```
         public Optional<Integer> findFirstGreaterThan(int n, Collection<Integer> numbers) {
         for (Integer num : numbers) {
            if(num > n) return Optional.of(num); // число больше n найдено
         }
          return Optional.empty(); // в переданных числах, нет числа больше чем n
          }
        ```
- для обработки методы
    - isPresent и isEmpty;
    - ```
         Optional<Double> optionalPrice = Optional.of(123.4);
         System.out.println(optionalPrice.isPresent()); // вернёт true
         System.out.println(optionalPrice.isEmpty()); // вернёт false
      ```
    - get - Используется для получения результата, содержащегося в Optional
        - если объект Optional не содержит значения, то вызов этого метода приведёт к генерации исключения
          NoSuchElementException
      ```
         Optional<Integer> optNumber = findFirstGreaterThan(5, Set.of(1, 2, 3, 4));
        if (optNumber.isPresent()) { // проверяем, что объект класса Optional содержит значение
            // вызываем метод get, чтобы получить значение, содержащееся в Optional
            System.out.println("Найденное число равно: " + optNumber.get());
        }
      ```
    - orElseThrow, orElse и orElseGet; - получить содержащееся в Optional значение, либо задать поведение в случае, если
      объект класса Optional пуст.
    - orElseThrow
        - в качестве аргумента принимает лямбду, возвращающую исключение, которое нужно выбросить, если Optional пуст.
        - Этот метод используется, если для логики программы отсутствие значения критично и работа не может быть
          продолжена
    - orElse
        - задать значение по умолчанию. В качестве аргумента он принимает значение того же типа, что и значение внутри
          Optional.
        - Именно оно будет возвращено, если Optional окажется пустым
    - orElseGet
        - в качестве аргумента принимает лямбду типа Supplier.
        - Этот метод нужно использовать, когда вычисление значения по умолчанию является дорогой операцией и его
          выполнение нужно отложить.
        - До того момента, пока не будет точно известно, что Optional пуст.
    - ifPresent
        - Позволяет выполнить действие со значением внутри Optional.
        - Этот метод полезен, если значение внутри Optional нам нужно разово, при этом для логики программы не
          принципиально, если значение отсутствует вовсе.
        - В качестве аргумента данный метод принимает лямбду типа Consumer
    - ifPresentOrElse
        - Позволяет указать, какие нужно выполнить действия в ситуации, когда внутри Optional есть значение, и в
          ситуации, когда нет.
        - В качестве аргументов принимает две лямбды типа Consumer и Runnable.
        - ```
          // Вызываем метод, возвращающий Optional<Integer>, и передаём две лямбды
          // Первая выполнится в случае, если Optional не пуст,
          //  вторая — если пуст
          findFirstGreaterThan(5, Set.of(1, 2, 3, 4))
             .ifPresentOrElse(
                number -> System.out.println("Найденное число равно " + number),
                () -> System.out.println("Число не найдено")
             );
          ```
- Optional в Java предназначен только для использования в качестве возвращаемого значения метода в тех случаях,
    - когда отсутствие значения является валидным результатом его работы
- Правильное использование Optional
    - в качестве возвращаемого значения метода в тех случаях, когда отсутствие значения является валидным результатом
- Неправильное использование Optional
    - в качестве типа данных у параметров метода
    - в качестве типа данных у поля класса
    - оборачивать коллекции в Optional - если значение отсутствует, достаточно пустой коллекции
    - в качестве элементов коллекции
    - распаковывать Optional при помощи метода get без проверки

### Стримы и Optional

```
package src;

import java.util.*;

class Candy {
    final String name;
    final String producer;
    final int price;
    final int amountSold;
    final Set<String> alternateNames;

    public Candy(String name, String producer, int price, int amountSold, Collection<String> alternateNames) {
        this.name = name;
        this.producer = producer;
        this.price = price;
        this.amountSold = amountSold;
        this.alternateNames = Set.copyOf(alternateNames);
    }

}

public class OptionalNameDemo {
    public static void main(String[] args) {
        Candy candy1 = new Candy("Мишка на севере", "Первая кондитерская фабрика", 28, 4, Set.of("Мишка косолапый", "Мишка"));
        Candy candy2 = new Candy("Мишка в лесу", "Триумф", 32, 2, Set.of("Мишка косолапый"));

        List<Candy> candies = new ArrayList<>();
        candies.add(candy1);
        candies.add(candy2);

        //добавляем конфету фабрики Главная шоколадная фабрика
        //раскомментируйте строчку, чтобы Optional стал не пустым
        //candies.add(new Candy("Шоколадный полет", "Главная шоколадная фабрика", 84, 0, Set.of("ШОКОЛАДНЫЙ ПОЛЕТ")));

        Optional<Candy> maybeChokoCandy = candies.stream()
                //выбираем только конфеты Главной шоколадной фабрики
                .filter(candy -> candy.producer.equals("Главная шоколадная фабрика"))
                //получаем первую из них
                .findFirst();

        maybeChokoCandy.ifPresentOrElse(
                //если Optional не пуст
                candy -> System.out.println(candy.name),
                //если Optional пуст
                () -> System.out.println("Такой конфеты не существует ifPresentOrElse")
        );

        //если такая конфета существует, выводим ее название
        if (maybeChokoCandy.isPresent()) {
            Candy chokoCandy = maybeChokoCandy.get();
            System.out.println(chokoCandy.name);
        } else {
            System.out.println("Такой конфеты не существует");
        }
    }
}

```

### Unix - время, Класс Instant

- Unix Epoch - Точку начала, 0 часов 0 минут 0 секунд 1 января 1970 года
- Unix time - саму систему представления времени
- UTC (англ. Coordinated Universal Time, «всемирное координированное время»)
    - добавляют или убавляют дополнительное время — это называется смещением относительно UTC
- > Unix-время соответствует времени UTC без какого-либо смещения — его ещё иногда обозначают как UTC0.
- timestamp (англ. «метка времени») - Количество времени в миллисекундах от Unix-эпохи

### Класс Instant

- представляет метки времени
- Он хранит не только количество миллисекунд от эпохи Unix, но и количество наносекунд
- методы
    - now() - получить текущую метку времени
        - toString() - то дата и время будут выведены в формате ISO-8601: год-месяц-деньTчасы:минуты:секундыZ
        - Instant instant = Instant.now(); System.out.println(instant);
    - toEpochMilli() - Посчитать количество миллисекунд с Unix-эпохи до конкретной метки времени
        - ofEpochSecond(long epochSecond), ofEpochMilli(long epochMilli) и ofEpochSecond(long epochSecond, long
          nanoAdjustment)
        - если известно секунды, миллисекунды, наносекунды
- получить время до Unix-эпохи - передать отрицательное число
- Верхняя граница содержится в константе Instant.MAX, нижняя — в Instant.MIN
- Экземпляры класса Instant — неизменяемые
    - нельзя поменять время: например, перевести его на час вперёд
    - можно воспользоваться специальными методами для создания нового экземпляра на основе старого, но с другим временем
    - plusSeconds(long secondsToAdd) — создаёт экземпляр класса Instant, который будет отличаться от текущего на
      secondsToAdd секунд в бóльшую сторону;
    - plusMillis(long millisToAdd) — на millisToAdd миллисекунд в бóльшую сторону;
    - plusNanos(long nanosToAdd) — на nanosToAdd наносекунд в бóльшую сторону.
    - minusSeconds(long secondsToSubtract) — на secondsToSubtract секунд;
    - minusMillis(long millisToSubtract) — на millisToSubtract миллисекунд;
    - minusNanos(long nanosToSubtract) — на nanosToSubtract наносекунд.
- сравнение моментов
    - isAfter(Instant otherInstant) — возвращает true, если время в экземпляре Instant, у которого вызывается метод,
      находится на временной шкале позже, чем otherInstant; и false — в противоположном случае;
    - isBefore(Instant otherInstant) — возвращает true, если время в экземпляре Instant, у которого вызывается метод,
      находится на временной шкале раньше, чем otherInstant; и false — в противоположном случае;
    - equals(Object otherInstant) — возвращает true, если оба экземпляра указывают на один и тот же момент во времени.

### Классы LocalDateTime, LocalDate и LocalTime

- требуется работать со временем как с часами и календарём — узнавать и учитывать в программе текущее время и дату
- LocalDateTime
    - Сохранить текущую дату и время
    - LocalDateTime localDateTime = LocalDateTime.now();
    - Информацию о текущем времени программа берёт из устройства, на котором она запущена
    - создать с заданными параметрами - год, месяц, день месяца, часы, минуты, секунды, наносекунды
        - LocalDateTime localDateTime = LocalDateTime.of(1990, 6, 30, 12,12,0,0);
        - LocalDateTime montsDate = LocalDateTime.of(2016, Month.JUNE, 16, 12, 12);
        - System.out.println(montsDate);
- import java.time.Month; - месяц из констант перечисления java.time.Month
- методы для получения новых экземпляров
    - Каждый вызов метода возвращает новый экземпляр класса:
    - plusYears(long years)/minusYears(long years) — создаёт новый экземпляр даты и времени с прибавлением/вычитанием
      указанного количества лет;
    - plusMonths(long months)/minusMonths(long months) — новый экземпляр с прибавлением/вычитанием количества месяцев;
    - plusWeeks(long weeks)/minusWeeks(long weeks) — количества недель;
    - plusDays(long days)/minusDays(long days) — дней;
    - plusHours(long hoursToAdd)/minusHours(long hoursToSubtract) — часов;
    - plusMinutes(long minutesToAdd)/minusMinutes(long minutesToSubtract) — минут;
    - plusSeconds(long secondstoAdd)/minusSeconds(long secondsToSubtract) — секунд;
    - plusNanos(long nanosToAdd)/minusNanos(long nanosToSubtract) — наносекунд.
    - LocalDateTime currentDateTime = LocalDateTime.now(); LocalDateTime twoWeeksAgo = currentDateTime.minusWeeks(2);
        - можно цепочкой
            - LocalDateTime newDateTime = currentDateTime.plusMonths(3).plusWeeks(2);
- LocalDateTime можно сравнивать друг с другом
    - isBefore(LocalDateTime otherMoment) — проверяет, находятся ли дата и время на временной шкале раньше, чем дата и
      время, переданные в качестве параметра.
        - Например, lastYear.isBefore(nextYear) вернёт true, если lastYear находится на временной шкале раньше, чем
          nextYear.
    - isAfter(LocalDateTime otherMoment) — проверяет, находятся ли дата и время на временной шкале позже, чем дата и
      время, переданные в качестве параметра.
        - Например, nextYear.isAfter(lastYear) вернёт true, если nextYear находится на временной шкале позже, чем
          lastYear.
    - equals(LocalDateTime otherMoment) — проверяет, равны ли две даты и их время.
        - Например, LocalDateTime.now().equals(newYear) вернёт true, если текущие дата и время будут равны newYear.

#### LocalDateTime и текст

- Если конвертировать экземпляр LocalDateTime в текст, то получится не самая читаемая строка в формате ISO 8601:
    - 2021-12-21T21:21:21.121212
- для этого есть DateTimeFormatter
    - В его экземплярах описывается нужный формат вывода с помощью метода ofPattern(String pattern)
        - dd — день,
        - MM — месяц,
        - yyyy — год,
        - HH — час,
        - mm — минуты,
        - ss — секунды,
        - SSS — дробная часть секунд.
      ```
         LocalDateTime localDateTime = LocalDateTime.now();

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yy");
        String formatDateTime = localDateTime.format(formatter);
        System.out.println(formatDateTime); // 21.10.24
      ```
- обратно из строкового в LocalDateTime
    - parse(..)
    - даже такое 14_02_1966|14:09 - DateTimeFormatter.ofPattern("dd_MM_yyyy|HH:mm");
    - либо String input = "14 часов 09 минут. Месяц: 02, День: 14, Год: 1966.";
        - DateTimeFormatter.ofPattern("HH часов mm минут. Месяц: MM, День: dd, Год: yyyy.");

```
LocalDateTime dateTime = LocalDateTime.parse("2021-12-21T21:21:21");
System.out.println(dateTime);

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm");

LocalDateTime anotherDateTime = LocalDateTime.parse("22.02.2022, 22:22", formatter);
System.out.println(anotherDateTime);

System.out.println(dateTime.isAfter(anotherDateTime));    
```

- время может понадобиться без даты, и наоборот: в некоторых задачах нужна дата, но не время
    - LocalDate - аналогично LocalDateTime, оперирует годом, месяцем и днём;
    - LocalTime - аналогично LocalDateTime, часами, минутами, секундами и наносекундами

```
LocalTime someTime = LocalTime.of(12, 15, 35, 999);
        LocalTime anotherTime = LocalTime.of(12, 15);

        System.out.println(someTime); // 12:15:35.000000999
        System.out.println(anotherTime); // 12:15

// создаём экземпляр LocalDate, в котором будет храниться 32-й день в году
        LocalDate someDate = LocalDate.ofYearDay(2000, 32);
        // это 1 февраля 2000 года

        System.out.println(someDate); // 2000-02-01
```

- LocalDate и LocalTime можно извлечь из LocalDateTime и обратно

```
LocalDateTime dateTime = LocalDateTime.now();

// извлечём время
LocalTime time = dateTime.toLocalTime();
System.out.println(time);

// извлечём дату
LocalDate date = dateTime.toLocalDate();
System.out.println(date);

 // создадим по отдельности дату и время
LocalTime time = LocalTime.now();
LocalDate date = LocalDate.now();
        
// соберём их вместе — в экземпляр LocalDateTime
LocalDateTime newDateTime = LocalDateTime.of(date, time);
System.out.println(newDateTime);
```

- Из LocalDateTime, LocalDate и LocalTime можно извлечь нужные единицы времени с помощью методов:
    - getYear() — возвращает год,
    - getMonth() — константу месяца,
    - getMonthValue() — номер месяца,
    - getDayOfMonth() — день месяца,
    - getHour() — часы,
    - getMinute() — минуты,
    - getSecond() — секунды,
    - getNano() — наносекунды.
    - getDayOfYear() — возвращает порядковый номер дня в году,
    - getDayOfWeek() — возвращает день недели — константу java.time.DayOfWeek.

### Классы Period и Duration

- Period
    - для вычисления срока между двумя датами
    - методы
        - getYears() - продолжительность в годах
        - getMonths()() - продолжительность в месяцах
        - getDays()() - продолжительность в днях
    - простой способ узнать продолжительность
        - статический метод between(LocalDate startDateInclusive, LocalDate endDateExclusive)
            - День, обозначенный датой endDateExclusive, в расчёте не учитывается

```
LocalDate today = LocalDate.now();
// напишите здесь свою дату рождения
LocalDate birthday = LocalDate.of(1990, 1, 2);

Period age = Period.between(birthday, today);
System.out.println("Ваш возраст:");
System.out.println("Лет: " + age.getYears());
System.out.println("Месяцев: " + age.getMonths());
System.out.println("Дней: " + age.getDays());
```

- Duration
    - хранит продолжительность времени с точностью до наносекунд и используется для вычисления длительности времени
      между двумя моментами
    - between(...)

```
LocalDateTime now = LocalDateTime.now();
        // напишите здесь свою дату рождения с точностью до часов и минут
        int yearOfBirth = 1990;
        Month monthOfBirth = JANUARY;
        int dayOfMonth = 1;
        int hourOfBirth = 9;
        int minuteOfBirth = 0;
        LocalDateTime birthday = LocalDateTime.of(yearOfBirth, monthOfBirth, dayOfMonth, hourOfBirth, minuteOfBirth);

        Duration duration = Duration.between(birthday, now);

        System.out.println("На момент запуска кода вы прожили " + duration.getSeconds()
                + " секунд и " + duration.getNano() + " наносекунд.");
```

#### Создание объектов Duration и Period

- Period.toString() - P(количество лет)Y(количество месяцев)M(количество дней)D
- Перечислить все составляющие промежутка: года, месяцы и дни для Period:
  // промежуток длиной 100 лет, 10 месяцев, 1 день
  Period longTime = Period.of(100, 10, 1);
- Воспользоваться методами по созданию промежутка из конкретной величины. Для Period:
    - ofDays(int days) — создаёт экземпляр Period длительностью days дней,
    - ofWeeks(int weeks) — длительностью weeks недель,
    - ofMonths(int months) — длительностью months месяцев,
    - ofYears(int years) — длительностью years лет.
- Duration
    - PT(количество часов)H(количество минут)M(количество секунд)S
    - ofSeconds(long seconds) — создаёт экземпляр Duration длительностью seconds секунд,
    - ofSeconds(long seconds, long nanoAdjustment) — длительностью seconds секунд и nanoAdjustment наносекунд,
    - ofMinutes(long minutes) — длительностью minutes минут,
    - ofHours(long hours) — длительностью hours часов,
    - ofDays(long days) — длительностью days дней.
    - getSeconds() и getNano() - продолжительность: количество секунд и дробная часть секунды — в наносекундах

```
Duration tenMinutes = Duration.ofMinutes(10);
        System.out.println(tenMinutes);

        Duration fiveDays = Duration.ofDays(5);
        System.out.println(fiveDays);

        Duration sixHours = Duration.ofHours(6);
        System.out.println(sixHours);

        Duration someTime = Duration.ofSeconds(59, 100);
        System.out.println(someTime);
        
PT10M
PT120H
PT6H
PT59.0000001S

```

```
 Random random = new Random();

        // фиксируем начало выполнения кода
        LocalDateTime start = LocalDateTime.now();

        // производим действия, время исполнения которых хотим замерить
        int num = random.nextInt(5000);
        Thread.sleep(num); // останавливаем выполнение кода на произвольное время

        // фиксируем конец выполнения кода
        LocalDateTime finish = LocalDateTime.now();

        // находим продолжительность между двумя моментами
        Duration duration = Duration.between(start, finish);

        // выводим результат
        System.out.println("Код выполнился за " + duration.getSeconds() + "." + duration.getNano() + "с.");
```

- Duration удобные методы
    - toDays() — возвращает целое число дней в промежутке;
    - toHours() — целое число часов;
    - toMinutes() — целое число минут;
    - toMillis() — целое число миллисекунд;
    - toNanos() — целое число наносекунд;
    - toHoursPart() — возвращает количество часов от неполного дня;
    - toMinutesPart() — количество минут от неполного часа;
    - toSecondsPart() — количество секунд от неполной минуты;
    - toMillisPart() — количество миллисекунд от неполной секунды.

```
LocalTime secondTime = LocalTime.of(23, 40);
        LocalTime firstTime = LocalTime.of(14, 25);

        Duration duration = Duration.between(firstTime, secondTime);

        System.out.println("Между двумя моментами времени:");
        System.out.println(duration.toHours() + " часов, " + duration.toMinutesPart() + " минут,");
        System.out.println("или " + duration.toMinutes() + " минут.");
```

### Часовые пояса: класс ZonedDateTime

- LocalDateTime, но с добавлением ZoneId — временной зоны
- Работать с ZoneId можно двумя способами: с фиксированным смещением относительно UTC и с привязкой к конкретному
  региону на Земле
- задать фиксированное смещение (UTC[+/-]hh:mm)
    - ZoneId zoneUtc = ZoneId.of("UTC-03:45");

```
LocalDateTime dateTime = LocalDateTime.now();
System.out.println(dateTime);

ZoneId zoneId = ZoneId.of("UTC+3");
System.out.println(zoneId);

ZonedDateTime zonedDateTime = ZonedDateTime.of(dateTime, zoneId);
System.out.println(zonedDateTime);
        
2024-10-21T14:58:35.503927400
UTC+03:00
2024-10-21T14:58:35.503927400+03:00[UTC+03:00]
```

- Чтобы избежать проблем с историческим изменением часовых поясов в конкретном месте, в Java есть второй вариант
  хранения времени.
    - Он позволяет привязаться к конкретному региону
    - ZoneId zoneId = ZoneId.of("Europe/Moscow");
        - Europe/Moscow — Москва,
        - Asia/Yekaterinburg — Екатеринбург, Пермь,
        - Asia/Vladivostok — Владивосток,
        - America/New_York — Нью-Йорк,
        - America/Toronto — Торонто,
        - Japan — Япония.

```
LocalDateTime dateTime = LocalDateTime.now();
ZoneId zoneId = ZoneId.of("Europe/Moscow");
ZonedDateTime zonedDateTime = ZonedDateTime.of(dateTime, zoneId);

System.out.println(zonedDateTime);

2024-10-21T15:00:31.974842200+03:00[Europe/Moscow]

// сохраняем временную отметку запуска первого искусственного спутника
Instant moment = Instant.ofEpochSecond(-386310686L);
System.out.println("Timestamp: " + moment);

// сохраняем её как московское время:
ZoneId zone = ZoneId.of("Europe/Moscow");
ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(moment, zone);

System.out.println(zonedDateTime);

Timestamp: 1957-10-04T19:28:34Z
1957-10-04T22:28:34+03:00[Europe/Moscow]
```

- Методы в ZonedDateTime такие же, как и в LocalDateTime
- Для создания экземпляра с изменением временной зоны есть два метода
    - withZoneSameInstant(ZoneId zone) - метод, аналогичный переводу часов: момент времени, на который указывает
      экземпляр,
        - остаётся неизменным, меняется LocalDateTime и ZoneId
    - withZoneSameLocal(ZoneId zone) - метод, аналогичный выбору другого часового пояса при настройке телефона:
        - часы будут показывать то же самое время, но зона будет другой
        - Например, электронная рассылка должна прийти пользователям по всему миру в одно и то же время, но по местному
          часовому поясу
            - сначала нужно рассчитать время и дату с часовым поясом, который установлен на сервере рассылки,
            - а затем, меняя часовые пояса, можно будет определить, в какое именно время нужно отправлять письма
              адресатам из разных регионов

```
Instant now = Instant.now();

// сохраняем московское время:
ZoneId moscowZone = ZoneId.of("Europe/Moscow");
ZonedDateTime moscowDateTime = ZonedDateTime.ofInstant(now, moscowZone);

// меняем регион на Нью-Йорк
ZoneId newYorkZone = ZoneId.of("America/New_York");
ZonedDateTime newYorkDateTime = moscowDateTime.withZoneSameLocal(newYorkZone);

System.out.println(moscowDateTime);
System.out.println(newYorkDateTime);

2024-10-21T15:04:02.708658700+03:00[Europe/Moscow]
2024-10-21T15:04:02.708658700-04:00[America/New_York]
```

- Форматирование для ZonedDateTime идентично LocalDateTime,
    - VV — название временной зоны,
    - ZZZZZ — смещение в формате +03:00.

```
Instant now = Instant.now();

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("Время: HH:mm:ss. Регион: VV, смещение: ZZZZZ");

ZoneId zone = ZoneId.of("Asia/Dubai");
ZonedDateTime dateTime = ZonedDateTime.ofInstant(now, zone);

System.out.println(dateTime.format(formatter));

Время: 16:05:10. Регион: Asia/Dubai, смещение: +04:00
```

### Тестирование

- тест-кейс состоит из трёх частей
    - Подготовка — определение входных параметров и предусловий.
        - что нужно, чтобы начать тест?
        - Какие данные нам потребуются?
    - Исполнение — определение процедуры тестирования
        - Как именно мы проверяем, что программа работает корректно?
        - Какие для этого нужно вызвать методы?
        - Какая будет последовательность действий?
    - Проверка — сравнение ожидаемого результата с полученным
- JUnit - фреймворк для тестов
- фреймворк - особый класс библиотек
    - в нем содержится набор классов и методов
    - может использовать ваш код в своей работе (библиотека при это просто дает классы и методы)
- методы
    - assertEquals(Object object) - проверка объекта на null (вместо Assertions.assertEquals(null, value))
    - assertNotEquals(Object object) - проверка, что не null
    ```
        @Test
        public void shouldBeNull() {
          String nullString = null;
          Assertions.assertEquals(null, nullString);
        }

    ```
    - assertTrue(...), assertFalse(...) - проверка на true/false, аналог assertEquals(true, value) или assertEquals(
      false, value)
- если сравнивать приватные поля будет ошибка, поэтому надо определить метод equals в классе

```
class IncorrectEqualsTest {

    @Test
    public void shouldReturnEquals() {
        Item item1 = new Item("яблоки", 50);
        Item item2 = new Item("яблоки", 50);

        assertEquals(item2, item1);
    }
}

class Item {

    private String name;
    private int price;

    public Item(String name, int price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Item item = (Item) o;
        return price == item.price && Objects.equals(name, item.name);
    }
}
```

- equals(..). Его нельзя переопределить для массивов
    - assertThrows(...) - проверка выбросит ли метод исключение
- если в одном тесте несколько раз создается объект класса, лучше вынести в поле
    - но только если класс идемпотентен

### Тестовое окружение

- Среда, или окружение (англ. environment) — это сервер или группа серверов, на которых находится копия приложения.
    - Конкретное окружение часто называется стендом
- Среда разработки (англ. development environment), dev или dev-стенд.
    - Используется исключительно для разработки. Именно сюда стекаются изменения от всех программистов, работающих над
      проектом.
    - Здесь же запускаются тесты, написанные разработчиками, и ставятся эксперименты
- Тестовая среда (англ. test environment), test или test-стенд.
    - Здесь продукт стабилизируется при помощи более сложных тестов.
        - Например, интеграционных (англ. integration tests) — которые объединяют (интегрируют) несколько
          программ/сервисов вместе.
        - При интеграционном тестировании часто проверяют, корректно ли данные из одного сервиса передаются в другой.
    - Такие тесты часто пишут отдельные команды тестировщиков.
- Продуктовая среда (англ. production environment), или prod.
    - Её ещё называют «боевая среда» как противоположность тестовой, «учебной».
    - С ней взаимодействуют клиенты компании, поэтому любые ошибки могут привести к денежным и репутационным потерям.
    - В идеальном мире к моменту выкладки кода на прод в программе уже не должно быть багов, влияющих на пользователя.
- аннотации запуска тестового окружения
    - @BeforeEach - перед каждым перед любым тестом, как раз для создания экземпляра класса для каждого теста

```
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Collections;

public class OvercomplicatedCookieFactoryTest {

    private static OvercomplicatedCookieFactory cookieFactory;

    @BeforeEach
    public void beforeEach() {
        cookieFactory = new OvercomplicatedCookieFactory(
                Collections.singletonList("Вам повезёт!"),
                Collections.singletonList("Сегодня будет дождь."),
                true
        );
    }

    @Test
    public void shouldReturnPositiveCookie() {
        String cookieText = cookieFactory.bakeFortuneCookie();
        Assertions.assertEquals("Вам повезёт!", cookieText);
    }

    @Test
    public void shouldIncreaseCounterByOneAfterCookieBaked() {
        cookieFactory.bakeFortuneCookie();
        Assertions.assertEquals(1, cookieFactory.getCookiesCreated());
    }
}
```

- @BeforeAll (англ. «перед всеми») — один раз до запуска всех тестов;
- @AfterEach (англ. «после каждого») — каждый раз после окончания каждого теста;
- @AfterAll (англ. «после всех») — один раз после окончания всех тестов.
- Аннотации, срабатывающие один раз: @BeforeAll и @AfterAll, должны стоять над статическим методом.
    - Если метод будет не статичный, тест попросту не запустится.

#### Граничные значения и классы эквивалентности

- Граничные значения (англ. boundary values) — это параметры, при переходе через которые поведение программы меняется.
    - Написать как минимум по одному тесту на каждое из граничных значений,
        - а также по одному — на любое значение из каждого промежутка класса эквивалентности
    - Проверить работу программы на каждом из граничных значений +/- одно значение
- Классы эквивалентности (англ. equivalence class) — параметры, при вводе которых программа ведёт себя одинаково.

#### Покрытие кода

- покрытие кода (англ. code coverage), показывает, какой процент строк кода исполняется при запуске всех тестов
    - Часто тестовое покрытие считают не от всего кода, а только от бизнес-логики (англ. business logic) программы
    - не входят файлы конфигураций, настройки окружения и модели объектов
    - Распространённая практика — устанавливать порог тестового покрытия бизнес-логики в 80%.
- покрытие требований (англ. requirements coverage), она показывает процент требований, проверенных набором тестов.

### Internet

- URL - Uniform Resource Locator
    - http://info.cern.ch/hypertext/WWW/TheProject.html
        - http - протокол
        - info.cern.ch — имя сервера, которому отправляется запрос
        - hypertext/WWW/TheProject.html — местоположение ресурса на сервере
- API - Application Programming Interface
- end-point - эндпоинт - комбинация URL-адреса и HTTP-метода
- путь (англ. path) — часть URL, отвечающая за местоположение ресурса на сервере.
- Сокет (от англ. socket — «разъём», «розетка») — это средство операционной системы, через которое программа может
  получить доступ к сети.
    - Процесс получения доступа называется открытием сокета.
    - IP-адрес и номер сетевого порта считаются параметрами сокета.

### HttpServer

- HttpServer.create(new InetSocketAddress(8080), 0); // создали и сразу привязали веб-сервер к порту
    - 0 - беклог, число соединений в ожидании (0 - стандартное число подключений)
    - либо аналогично
        - HttpServer httpServer = HttpServer.create();
        - httpServer.bind(new InetSocketAddress(8080), 0);
- HttpHandler - интерфейс для эндпоинтов

```
public class HelloHandler implements HttpHandler {
    @Override
    public void handle(HttpExchange httpExchange) throws IOException {

        String response = "Hey, its mu first Java http server";
        httpExchange.sendResponseHeaders(200, 0);

        try (OutputStream os = httpExchange.getResponseBody()) {
            os.write(response.getBytes());
        }
    }
}
```

- связываем сервер и обработчик
    - httpServer.createContext("/hello", new HelloHandler());
- запуск сервера
    - httpServer.start();
- для формирования JSON используется класс
    - POJO (от англ. Plain Old Java Object — «простой классический Java-объект»). Слово «простой» здесь означает,
        - что эти классы не наследуют поведение от классов сторонних библиотек.

```
public class UserPost {
    // URL-адрес, по которому можно скачать фото
    private String photoUrl;

    // Дата публикации
    private LocalDate publicationDate;

    // Уникальный идентификатор автора поста
    private int userId;
    // Текстовой комментарий к фото
    private String description;
    // Сколько людей поставило лайк этому посту
    private int likesQuantity;

    public LocalDate getPublicationDate() {
        return publicationDate;
    }

    public void setPublicationDate(LocalDate publicationDate) {
        this.publicationDate = publicationDate;
    }

    public String getDescription() {
        return description;
    }
...
```

- сериализация (англ. serialization) - Процесс трансформации Java-объекта в какой-то другой формат
- десериализация (англ. deserialization) - обратный процесс
- GSON - библиотека, позволяющая трансформировать Java-объекты в JSON, создана компанией Google
- десериализация - из строки в объект класса

```
   Gson gson = new Gson();
    String jsonString = "{\"name\":\"Тузик\",\"owner\":{\"name\":\"Игорь\",\"surname\":\"Петров\"},\"age\":\"3\"}";

    Dog dog = gson.fromJson(jsonString, Dog.class);
    System.out.println(dog.getAge());
        
    // создайте экземпляр класса Owner (владелец)
        Owner owner = dog.getOwner();

        String ownerStr = gson.toJson(owner);
        System.out.println(ownerStr);
        
    class Dog {
    private String name;
    private Owner owner;
    private int age;

    public Dog(String name, Owner owner, int age) {
        this.name = name;
        this.owner = owner;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

class Owner {
    private String name;
    private String surname;

    public Owner(String name, String surname) {
        this.name = name;
        this.surname = surname;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }
}s
```

#### Другие возможности GSON

- GsonBuilder - отдельный класс-строитель, который обеспечивает удобное построение объектов других классов
- -prettyPrinting()
    - по умолчанию выключено
    - читабельный вывод JSON

```
GsonBuilder gsonBuilder = new GsonBuilder();
        gsonBuilder.setPrettyPrinting();
        Gson gson = gsonBuilder.create();
```