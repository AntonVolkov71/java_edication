### JDK

- Java Development Kit - комплект для разработки
    - компилятор
    - программа для выполнения байт-кода
    - стандартная библиотека Java
    - генератор документации из комментариев к коду
- JDK
    - OpenJDK бесплатный, но доступна последняя сборка без поддержки
    - Oracle - бесплатно, для коммерции платно

### Компилятор javac

- компилятор кода программы в байт-код
- создает файл с расширением .class

### JVM

- Java Virtual Machine
- выполнение построчно байт-кода
- проверяет на наличие ошибок в байт-коде

### Скачать Java

- Разрядность x64: https://corretto.aws/downloads/latest/amazon-corretto-11-x64-windows-jdk.msi.
- Разрядность x86: https://corretto.aws/downloads/latest/amazon-corretto-11-x86-windows-jdk.msi.
- JDK будет находиться здесь:  C:\Program Files\Amazon Corretto\.
- задать переменную JAVA_HOME C:\Program Files\Amazon Corretto\jdk[version]\bin
- добавить путь в PATH C:\Program Files\Amazon Corretto\jdk[version]\bin

- Компиляция
    - один файл # javac -encoding UTF-8 HelloJdk.java
    - несколько файлов # javac -d bin -encoding UTF-8 *.java //bin название папки
- Запуск
    - # java -Dfile.encoding=UTF-8 HelloJdk
    - # java HelloJdk
    - запуск нескольких файлов # java -cp bin test_app.src.service.Main

### JAR

- Java Archive - java архив со всеми файлами, который можно передавать
- внутри JAR есть специальный текстовый файл с описанием структуры архива — файл манифеста MANIFEST.MF
    - генерируется автоматически при создании java-архива и находится по адресу META-INF/MANIFEST.MF
- перевести все файлы в байт-код, далее
    - # jar cfe <имя jar-файла> <имя стартового класса> <список файлов>
    - # jar cfe library.jar Practicum -C bin .
        - # Точка в конце строки указывает на то, что в JAR должны попасть все файлы из папки bin.
    - c (от англ. create, «создавать») указывает на то, что создаётся новый файл;
    - f (от англ. filename, «имя файла») предупреждает, что после него будет написано имя создаваемого jar-файла;
    - e (от англ. entrypoint, «точка входа») указывает на название класса, с которого нужно начать выполнение программы.
- несколько файлов test_app.src/Main.class и другие
    - создать файл MANIFEST.MF в bin - Main-Class: test_app.src.screenshot.Main
    - перейти в папку bin
        - jar cvf test.jar *
- когда есть файл jar можно запустить
    - # java -jar library.jar

### Упаковка в исполняемый файл exe

- Launch4j - использует jar архив

### Поэтапно компиляция

- структура src.screen.Main.java
- создаем MANIFEST.MF можно внутрь пакета для отдельного приложения либо в корень если один сервис
    - Main-Class: src.screen.Main
- из корня компилируем
    - javac -d bin src/screen/Main.java
- создаем jar из корня
    - jar cfm myapp.jar .\src\screen\MANIFEST.MF -C bin .
- запускаем проверяем
    - java -jar myapp.jar

### Примитивы

- Целочисленные
    - byte - 8бит - от -128 до 127
    - short - 16бит - от -32768 до 32767
    - int - 32бит - от -2 147 483 648 до 2 147 483 647 // используется в основном
    - long - 64бит - 18 нулей, обязательно указывать 123123L
- Дробные
    - float - 32бит - от -3.4*10^-38 до 3.4*10^38 // float number = 4.7E-23;
    - double - 64бит от -4.9*10^-324 до 4.9*10^308 // используется в основном
- Символьный
    - char - 16бит - одинарные кавычки
- Логический
    - boolean - true/false

### Значения по умолчанию

- если вывести незаданное поле класса будет ошибка
    - можно ошибиться когда инициализация по умолчанию задала null, а мы не задавали
- Целочисленные - 0
- Дробные - 0.0
- Логические - false
- Ссылочные (классы) - null
- char - \u0000

### Приведение типов

- при передачах аргумента типа, который входит в диапазон типа параметра, происходит автоматическое (неявное) приведение
  типа
    - byte передать в метод, где int - будет приведение
    - short -> long, float -> double
        - Long bigNum = 10L;
        - short smallNum = bigNum.shortValue()
- явное приведение
    - нельзя тип с большим диапазоном привести к меньшему - int -> byte Ошибка
    - можно самостоятельно привести (byte)integerValue - явное приведение
    - НО! если при явном приведении, значение больше чем диапазон меньшего, будет непредсказуемый результат
    - дробное можно к целочисленному, останется только целая часть

### Классы обертки

- "старшие братья" примитивов
- хранят ссылку, не имеют фиксированного размера, возвращают null, имеют свои методы
    - byte - Byte
    - short - Short
    - int - Integer
    - long - Long
    - float - Float
    - double - Double
    - char - Character
    - boolean - Boolean
- упаковка примитива автоматическая - boxing

```
  int primitive = 7;
  Integer wrapper = primitive;
  
  byte primitive = 3;
  method(primitive);
  
  ...    methjd(Byte num){}
    
    int a = 15;
    int b = 3;
    int c = -7;
    Integer[] numbers = new Integer[3];
    
    numbers[0] = a;
    numbers[1] = b;
    numbers[2] = c; 
    
```

- обратная распаковка типа - unboxing
- но если в классе обертке null, распаковка даст ошибку

```
  Boolean wrapper = true; // упаковали значение в класс-обёртку Boolean
  boolean primitive = wrapper; // распаковали обратно в примитив boolean

    // ошибка
    Float wrapper = null;
    float primitive = wrapper;
    System.out.println(primitive);
```

### Парсинг

- все, кроме Character, имеют метод, позволяющий преобразовывать строки в свой тип
- Числовые (кроме Byte, Short для них делать приведение типа) обертки имеют встроенные методы типа max, min, sum,

### Память Java

- СТЕК
    - жестко выделенная память
    - переменные примитивов хранятся в стеке
    - когда начинает выполнятся Метод, в стеке создается новый блок - фрейм стека, все переменные внутри стека, будут
      созданы
      внутри этого блока стека. При завершении метода, все переменные не доступны
    - поэтому когда мы передаем примитивы как аргументы они копируются в блок стека, все изменения переменных остается
      внутри блока
- КУЧА
    - динамическая память
    - хранятся объекты
    - классы передаются по ссылке, то есть при изменении внутри метода изменится значения в самом классе

### Приведение в арифметических выражениях

- если в double сохранить int1 / int2 - будет х.0, дробная часть будет 0!!
    - если хотя бы один операнд будет double, будет автоматическое приведение к double деления(то же самое, при
      сложении, вычитании и т.д.)

### Порядок вычислений

- Первыми отработают операторы префиксного инкремента и декремента — ++a и --a;
- Затем — операторы умножения, деления и остатка от деления: *, / и %;
- Третьи на очереди — операторы сложения и вычитания + и -;
- Последними выполняются операции с постфиксным инкрементом и декрементом: a++ и a--.

### Порядок логических операций

- Сначала всегда выполняется отрицание !.
- Логическое умножение предшествует сложению — поэтому логическое И && в приоритете.
- Логическое ИЛИ || при наличии других операций выполняется последним.

### Пакеты

- по сути это папка - namespace - пространство имен с файлами классов
- можно импортировать весь пакет, когда много классов import java.util.*;

### Списки & массивы

- java.util.ArrayList - список, хранит только Классы
- ArrayList<String> names = new ArrayList<>();
    - add, get - по несуществующему индексу вызовет исключение
    - add(E e) - добавить элемент, можно передать примитив (упаковка автоматическая)
        - add( int index, E e ) - если использовать index можно вставить в определенное место
    - get(int index) - получить по индексу
    - size() - размер
    - remove(int index)(Object o) - удаление по индексу либо по значению
    - clear() - очистить весь список
    - isEmpty() - пустой или нет
    - contains(E e) - возвращает Boolean, проверяет содержит или нет значение
- массив может хранить примитивы, ссылочные типы
    - length - всегда одно и тоже, так как задается длина при объявлении

### Хеш Таблицы

- он же словарь или ассоциативный массив (мапа, таблица)
- отображение сопоставление каждому объекту первого множества ровно один объект второго
- java.util.HashMap - вместо индекса используется ключ
- HashMap<String, Integer> ages = new HashMap<>();
    - O(1) - поиск по значению, добавление, обновление, удаление
    - не может быть два одинаковых ключа
    - ключи без определенного порядка
    - ключ может быть: число, символ, строка, объект
        - !обязательно переопределить hashCode(), equals()
    - если нет ключа вернёт Null
    - put(K key, V value) - вставка
    - values() - получение массива значений
    - keySet() - получение массива ключей
    - remove(Object key) - удаление по ключу
    - clear() - полностью очистка
    - containsKey(Object key) - проверка по ключу, вернет Boolean
    - containsValue(Object value) - проверка по значению, вернет Boolean
- интерфейс Map - родитель для всех хеш-таблиц
    - put(K key, V value) - вставка (запись), если есть перезапишет
    - containsKey(Object key) - содержит ключ или нет
    - containsValue(Object value) - содержит значение или нет
    - get(Object value) - содержит значение или нет (вернет null)
    - getOrDefault(Object key, V defaultValue) - если ключа нет, вернет значение по умолчанию
    - size() - размер по ключам
    - isEmpty() - пустой или нет
    - remove(Object key), clear() - удаление по ключу (возвращает значение или null)
    - keySet(), values(), entrySet() - итерирует по ключам, значениям, ключ+значение
  ```
    Map<String, String> countriesAndContinents = new HashMap<>();

    countriesAndContinents.put("Марокко", "Африка");
    countriesAndContinents.put("Танзания", "Африка");
    
    for (Map.Entry<String, String> el : countriesAndContinents.entrySet()) {
        System.out.println(el.getKey());
        System.out.println(el.getValue());
    }
  ```
    - интерфейсы
        - представляют дополнительные операции, если ключи хранятся в отсортированном виде
            - SortedMap
            - NavigableMap
    - классы
        - TreeMap
            - наследуется от NavigableMap <-- SortedMap
            - O(log n) - базовые операции, медленнее чем HashMap, так как внутри структура дерева
            - public TreeMap() - новая пустая хеш-таблица, без пустых ячеек
            - public TreeMap(Comparator <? super K> comparator) - передается компаратор - правила сравнения ключей
            - public TreeMap(Map<? extends K, ? extends V> m) - заполняет данными из переданной хеш-таблицы любого типа
            - public TreeMap(SortedMap<K, ? extends V> m)- заполняет данными из переданной хеш-таблицы, но типа
              SortedMap
            ```
                   // можно реализовать несколько вариантов Сортировки
                   Comparator<User> userComparator = new Comparator<>() {
                     @Override
                     public int compare(User user1, User user2) {
                       return user1.userId - user2.userId;
                     }
                   };

                   Map<User, String> users = new TreeMap<>(userComparator);
          
                    // интерфейс Comparable, когда Один способ сортировки
                     class User implements Comparable<User> {
                       public Integer userId;
                       public String username;
                        // ... и другие поля пользователя

                     @Override
                     public int compareTo(User o) {
                      return this.userId - o.userId;
                     }
                      }
            ```
            - методы
                - firstEntry(), firstKey() - первая запись по порядку (ключ-значение, ключ)
                - lastEntry(), lastKey() - последние данные
                - pollFirstEntry(), pollLastEntry() - возвращает данные и удаляет из таблицы
                - lowerEntry(K key), higherEntry(K key) - соседние данные
- LinkedHashMap
    - O(1) - поиск по значению, добавление, обновление, удаление,
        - но чуть медленнее, так как хранить двусвязный список

    - ключи хранятся в том порядке, в каком добавляются
        - 2 способа
            - в порядке добавления записей - первая первой, последняя последней
            - в порядке доступа к записям - при итерации первой будет, к которой дольше всего не обращались,
                - первой к которой было последнее обращение
    - наследуется от HashMap
    - конструктор создает новую хеш-таблицу со стандартными настройками
        - 16 пустых ячеек
        - коэффициент заполнения 75%
        - ключи будут отсортированы в порядке добавления
        - public LinkedHashMap(Map<? extends K, ? extends V> m)
            - заполняет данными из параметра m, создает идентичную копию переданной хеш-таблицы
        - public LinkedHashMap(int initialCapacity)
            - создает объект, в таблице сразу создано переданное количество ячеек
        - public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
            - какой тип сортировки ключей, accessOder == true - в порядке доступа, false - в порядке добавления
              записей (по умолчанию)
            -

### Коэффициент заполняемости HashMap

- по умолчанию 75%
- можно задать
    - public HashMap(int initialCapacity, float loadFactor)
    - loadFactor = 0.6 -> 60%

### Object

- методы
    - для генерации используем Generate-> equals hashCode -> next тех полей которые нужно
    - для генерации toString используем Generate-> etoString -> тех полей которые нужно
    - equals(Object) - возвращает результат проверки объектов на равенство, Используется
        - == - не подходит, так как используется только для примитивов,
        - для корректного сравнения нужно переопределить equals()
        - Необходимо переопределять!!!
        ```
          // по умолчанию
          public boolean equals(Object obj) {
            return (this == obj);
          }
      
          // корректное переопределение 
          class Book {
            public String title;
            public String author;
            public int pagesNumber;
          
            public Book(String title, String author, int pagesNumber) {
            this.title = title;
            this.author = author;
            this.pagesNumber = pagesNumber;
            }
          
            @Override
            public boolean equals(Object obj) {
            if (this == obj) return true; // проверяем адреса объектов
            if (obj == null) return false; // проверяем ссылку на null
            if (this.getClass() != obj.getClass()) return false; // сравниваем классы объектов
          
                  Book otherBook = (Book) obj; // привели второй объект к классу Book
          
                  return Objects.equals(title, otherBook.title) && // проверяем все поля
                          Objects.equals(author, otherBook.author) && // нужно логическое «и»
                          (pagesNumber == otherBook.pagesNumber); // примитивы сравниваем через ==
          
            }
          }
        ```
    - hashCode() - возвращает хеш-код объекта, Используется
        - Необходимо переопределять!!!
        - Базовая реализация метода hashCode() стремится создать уникальный хеш для каждого объекта, в том числе для
          идентичных
        - У всех стандартных ссылочных типов данных в Java (String, Integer, Double и т. д.) методы equals(Object) и
          hashCode() уже корректно переопределены
          ```
               @Override
               public int hashCode() {
                    int hash = 17;
                    if (firstName != null) {
                    // вычисляем хеш первого поля и добавляем к нему начальное значение
                      hash = hash + firstName.hashCode();
                    }
                    hash = hash * 31; // умножаем промежуточный результат на простое число

                    if (lastName != null) {
                    // вычисляем хеш второго поля и добавляем его к общему результату
                    hash = hash + lastName.hashCode();
                      }
                    return hash; // возвращаем итоговый хеш
               }
          ```
        - Три правила переопределения (контракт)
            - Если при сравнении методом equals(Object) объекты оказались равны, то hashCode() должен возвращать у
              каждого из них одно и то же число
            - метод hashCode() должен возвращать одно и то же целое число до тех пор, пока значения полей, используемых
              в методе equals(Object) того же класса, остаются прежними
            - Нужно стремиться к тому, чтобы у объектов, которые не равны при сравнении equals(Object), были разные
              хеш-коды, но учитывать, что они могут совпасть.
                - Поэтому, если у двух объектов одинаковые хеш-коды, нельзя утверждать, что объекты равны. Точный
                  результат покажет только метод equals(Object).
    - getClass() - возвращает класс объекта
    - toString() - строковое представление объекта, Используется
        - Необходимо переопределять!!!
        - только чтение, Не менять состояние объекта
        - В реализацию toString() стоит включать только те поля, которые содержат ключевую или определяющую информацию.
        - Статические или вспомогательные поля можно опустить.
        - Некоторые поля могут содержать объёмные данные. Нет практического смысла в том, чтобы выводить их полное или
          даже сокращённое содержание.
        - Можно отобразить их длину
        - В отдельном форматировании могут также нуждаться такие данные, как даты
        - println(Object) - выведет toString класса
        - соблюдать единй формат
            ```
              @Override // переопределяем toString
              public String toString() {
                return "Person{" + // имя класса
                       "firstName='" + firstName + '\'' + // поле1=значение1
                       ", lastName='" + lastName + // поле2=значение2
                       '}';
              }
            ```
    - clone() - копия объекта
    - wait(lon timeoutMillis) - освобождает монитор и переводит вызывающий поток в ожидание (параметр timeout не
      обязательный)
    - notify(), notifyAll() - возобновляет работу потока (потоков)

### Code style

- в стандарте оформления кода формулируются соглашения по следующим пунктам:
- максимальная длина строки,
- отступы,
- табуляция,
- пустые строки,
- скобки,
- пробелы внутри выражений и инструкций,
- стиль комментариев,
- принципы именования классов, переменных, методов и проч.
- Длина строки в коде должна быть не более 120 символов.
    - Перенос строки должен выполняться после запятой.
    -
        + / : . - на новую строку
  ```
  Плохо
    int period, action; 
    // На одной строке объявлено несколько переменных.
  
  Хорошо
    int period;
    int action;
    // Каждая переменная объявлена на отдельной строке
  ```

### Live Templates

- psvm - метод main
- sout — разворачивается в инструкцию System.out.println();.
- soutm — выводит в консоль имя текущего класса и метода. Например, System.out.println("LiveTemplates.main");.
- soutp — выводит в консоль аргументы метода. Например, System.out.println("args = " + Arrays.deepToString(args));.
- soutv — эта команда похожа на предыдущую, она выводит в консоль значение переменной в формате System.out.println("
  имяПеременной = " + имяПеременной);.
- ifn — создаст конструкцию if для поверки переменной на равенство null
- fori — создаст заготовку для цикла for с переменной i в качестве счётчика
- iter — создаст заготовку для цикла по массиву или списку.

### README.md

- Название проекта и его краткое описание: кем он создан, для чего, какие решает задачи и какие закрывает проблемы.
- Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
- Документация проекта — инструкция о том, как его запустить или протестировать. Здесь же можно найти системные
  требования: версия языка, необходимые расширения.
- Планы проекта, если они есть.

### Модификаторы доступа

- static - для класса, метода или переменной
    - для переменной - она будет привязана к самому класса, независимо от экземпляров,
        - если изменить, изменить для всех экземпляров
        - обращение через Имя класса
    - для метода - применение для утилитарных задач, метода которые не меняют состояние объекта
        - статический метод может обращаться только к статическим методам или переменным
        - Переопределять static (@Override) Нельзя
        - Если сохранить класс наследник как тип Родителя, то будут использоваться методы родителя, а не наследника
    - this, super - запрещены в static - методах!!
    - static import - обращение напрямую к переменным класса, не через класс
        - import static java.lang.Math.PI;
        - double area = PI * (radius * radius);
        - Лучше использовать это редко, будет нечитабельный код
- final - для всего, что нельзя менять, типа readonly TS
    - если примитив, то менять нельзя
    - если объект, менять нельзя, а менять состояние объекта можно
    - переменная на уровне класса Обязательно должна быть проинициализирована
        - либо в теле конструктора
    - для метода защищает от переопределения
    - для private метода не нужно final
    - для класса используется final, чтобы запретить наследование
        - все методы автоматически становятся final
- константы
    - это статическое финальное поле, изменить нельзя никак
    - обязательная инициализация
    - стиль SCREAMING_SNAKE_CASE
- Enum
    - по сути своей static final
    - с большой буквы - public enum DayOfWeek {}
    - new не нужен при инициализации FilmGenre genre = FilmGenre.COMEDY;
    - методы:
        - equals() - сравнение как объекта, можно и ==, аккуратно enum может быть null
        - values() - массив значений
        - valueOf( String name) - возвращает значение если нашел, ошибка если нет
        - часто используется с switch
        - @Override toString() - можно переписать
      ```
        @Override
        public String toString() {
         return name().charAt(0) + name().substring(1).toLowerCase();
        }
      ```

### Абстракция

- доступны только методы, описывающие основное поведение, остальные детали скрыти
    - основной инструмент инкапсуляция
- абстрактный класс - у него не может быть экземпляров, только шаблон
    - может быть конструктор, поля, методы
    - абстрактные методы без реализации (заготовка)
        - public abstract void move();
        - @Override при инициализации метода в наследнике
    - но в абстрактном классе, могут быть обычные методы с реализацией
    - абстрактный класс не может быть пустым

### Интерфейсы

- наследоваться от класса можно только от одного класса
- Абстрактные классы нужны для того, чтобы у всех классов-наследников создавать и поддерживать общую структуру
- Интерфейсы нужны для добавления в класс-реализацию определённой функциональности
- интерфейсы не привязаны к определенному классу
- названия с большой буквы и суффикса -able (Iterable)
- класс либо должен объявить все методы интерфейса (@Override) либо объявить себя абстрактным
- все переменные будут константы
- модификаторы доступа для методов интерфейсов не нужно (публичные по умолчанию)
- расширение от интерфейса через implements
- класс может реализовать сразу Несколько интерфейсов
- интерфейс может расширяться от другого интерфейса (extends)

### Полиморфизм

- многообразный - способность принимать разные формы
- позволяет работать с объектами, имеющие одинаковый интерфейс, при этом не зная о конкретном типе объекта
- сохранять объект наследника в переменную с родительским типом
- позволяет программе взаимодействовать с объектами разных типов одинаково, если у них общий предок или интерфейс
- Классический
    - можем работать с типом который присвоили объекту
        - если несколько интерфейсов реализовано, то доступны будут только те методы, которые есть у этого типа
    - основан на расширении от родительского класса, то есть наследники связаны родительским типом
- Ad-hoc полиморфизм
    - динамический - основан на переопределении метода в наследуемых классах, метод будет вызван их того типа объекта,
      через который создали
        - в отличии от классического, расширение от интерфейса, нет необходимости наследования, более гибкий
    - статический - перегрузка методов
- Параметрический
    - поведение класса или метода, у которых все равно какой типа данные (Дженерики как TS)
    - дженерики можно использовать в интерфейсах
  ```
    public class Pair {
    public final Object key;
    public final Object value;

    public Pair(Object key, Object value) {
        this.key = key;
        this.value = value;
    }

    public void print() {
        System.out.printf("(%s, %s)", key, value);
    }

    public Object getKey() {
        return key;
    }

    public Object getValue() {
        return value;
    }

  ```

### Приведение ссылочных типов

- методы наследуемого объекта не будут доступны из родительского типа
- для получения наследуемых метод надо явно объявить объект с типом наследника
  ```
        Document document = new RussianPassport("1111", "567899");
        RussianPassport passport = (RussianPassport) document;
  ```
- при компиляции не будет ошибки, если наследника попробовать явно привести другого наследника
    - только при выполнении программы
- instanceof - проверка типа
- ограничения для дженериков <T extends Number>, передаваемый дженерик должен быть каким либо числом

```
     interface Document {}
     class RussianPassport implements Document {}
     class Snils implements Document {}
     Document document2 = new Snils("12345678901");
     
     RussianPassport passport = (RussianPassport) document2; // ОШИБКААААА
     
     // можно проверить
     boolean isPassport = document instanceof RussianPassport;
```

### Алгоритмы

- Асимптотическая сложность - количество операций, выполняемых алгоритмом
    - O(n) - линейный - растет линейно
    - O(log(n)) - логарифмический - двоичный логарифм
    - O(1) - константный - постоянный
    - O(n^2) - квадратная

### Сортировка

- слиянием - O(n * log(n)), n - памяти, устойчивая, может поддерживать сортировку по нескольким параметрам
- быстрая - O(n * log(n)) - память не требуется, неустойчивая
- вставками (insertion sort) O(n^2) - используется на маленьких объемах данных
    - разделяет массив на две части: отсортированную и не отсортированную
    - в начале в отсортированной части 0 элементов
    - на каждом шаге рассматриваем очередной элемент и пытаемся вставить в правильное место
- поразрядная - O(n) но только при определенных условиях
    - подсчитывает количество вхождений, а затем выводит в определенном порядке столько раз, сколько встречались
    - заранее известен диапазон сортируемых значений

### Структуры данных

- это совокупность трех компонентов:
    - набор данных
    - отношение между ними
    - все методы по управлению этими данными
- в Java за это отвечают коллекции - Java Collections Framework

### Иерархия коллекций

- Вершина первой части - интерфейс Iterable<T>
    - представляет инструменты для обхода, перебора слева направо
    - помимо forEach, можно воспользоваться Итератором
        - hasNext(), next()
    - прямой наследник интерфейс Collection<T>, его наследуют три интерфейса:
        - Set<T> - каждый элемент уникален
        - Queue<T> - элементы располагаются один за другим согласно очереди - FIFO
        - List<T> - создание списков, элементы могут повторяться, произвольный порядок, могут расширяться, сортировка
            - LinkedList<T> - двунаправленный связный список
                - наследуется от AbstractSequentialList<T> последовательный обход элементов друг за другом.
                - операции могут применяться с начала или конца
                - addFirst(), addLast() - добавляет в начало, конец
                - getFirst(), getLast() - получить первый, последний
                - removeFirst(), removeLast() - удаляет из начала, конца
                - add(int, T), remove(int), get(int) - операции по индексу
                - size() - размер
            - ArrayList<T> - основан на массиве список
                - динамический массив
                - два параметра:
                    - размер
                    - вместимость - число элементов, потенциально могут храниться, по умолчанию 10
                        - увеличивается на 50% после вместимость == размер
                - не только реализует List<T>, но и AbstractList<T>
                    - AbstractList<T> реализует List<T>
            - методы List<T>:
                - add(E e), add(int index, E e) - index индекс позиции вставки
                - get(int index) - получение по индексу
                - set(int index, E e ) - замена элемента по индексу
                - remove(E e), remove(int index) - удаление по элементу, по индексу
            - два способа преобразования массива или набора случайных чисел:
                - Arrays.asList(...) - можно создать и заполнить небольшой список одним выражением
                ```
                   String[] citiesArray = {"Воронеж", "Южно-Сахалинск", "Иркутск"};

                   List<String> cities = Arrays.asList(citiesArray);

                    System.out.println(cities); // [Воронеж, Южно-Сахалинск, Иркутск]
                ```
                - List.of(...)
                ```
                    String[] citiesArray = {"Воронеж", "Южно-Сахалинск", "Иркутск"};

                    List<String> cities = List.of(citiesArray);

                    System.out.println(cities);
                ```
                - при таком преобразовании, списки неизменяемы, не поддерживают удаление, добавление
        - методы Collection<T>:
            - add(E e) - добавление
            - contains(Object o) - проверка наличия
            - remove(Object o) - удаление
            - size() - количество элементов
            - isEmpty() - есть ли в коллекции элементы
            - поддерживает System.out.println(collection)
            - add | contains | remove All - добавление, проверка наличия, удаления сразу несколько
              ```
                Collection<String> colors = new ArrayList<>();
                Collection<String> colorsAdditional = new ArrayList<>();
              
                colors.addAll(colorsAdditional);
              ```
            - clear() - очистка
            - toArray() - трансформация в массив
- Вершина второй части - интерфейс Map<K, V> - ключ со значением типа V
    - задает однозначную одностороннюю связь
    - наследник HashMap<K,V>

### Comparator

- сравнение Comparator<T>
- помогает при сортировке сложных объектов
- добавляет метод int compare(T, T) - необходимо переопределить
- для лексикографической сортировки слов без учёта регистра
    - return String.CASE_INSENSITIVE_ORDER.compare(item1.name, item2.name);
- Классы-обёртки, такие, как Integer или Double
    - return Integer.compare(item1.price, item2.price);

```
class Item {

    public final String name; // название товара
    public final int price; // цена
    public final int popularity; // популярность

    public Item(String name, int price, int popularity) {
        this.name = name;
        this.price = price;
        this.popularity = popularity;
    }

    // сразу переопределим toString(), чтобы потом выводить содержание списка
    @Override
    public String toString() {
        return "Item{" +
                "name='" + name + '\'' +
                ", price=" + price +
                ", popularity=" + popularity +
                '}';
    }
}


class CompareItem implements Comparator<Item> {
    @Override
    public int compare(Item item1, Item item2) {
//        // сравниваем товары — более дорогой должен быть дальше в списке
//        if (item1.price > item2.price) {
//            return 1;
//
//            // более дешёвый — ближе к началу списка
//        } else if (item1.price < item2.price) {
//            return -1;
//
//            // если стоимость равна, нужно вернуть 0
//        } else {
//            return 0;
//        }

        return item1.price - item2.price;
    }
}

public class CompareTest {
    public static void main(String[] args) {
        // создаём список товаров
        List<Item> items = new ArrayList<>();
        items.add(new Item("Рубашка", 4500, 37));
        items.add(new Item("Носки", 55, 8));
        items.add(new Item("Толстовка", 1399, 74));
        items.add(new Item("Носки", 169, 19));

        System.out.println("До сортировки:");
        System.out.println(items);

        CompareItem compareItem = new CompareItem();
        items.sort(compareItem);

        System.out.println("После сортировки:");
        System.out.println(items);
    }
}
```

- метод reversed() - разворачивание

```
CompareItem compareItem = new CompareItem();
items.sort(compareItem);

System.out.println("После сортировки:");
System.out.println(items);

Comparator<Item> reversedComparator = compareItem.reversed();

items.sort(reversedComparator);
System.out.println(items);
```

### Класс помощник Collections

- утилитарный класс
- задача упрощения работы с другими классами
- методы
    - emptyList() - создает пустой список
    - singletonList(T) - создает список из единственного элемента
    - nCopies(int, T) - создает список, где элемент повторен n раз
    - при этом эти списки Неизменяемы!!
    - fill(List<T>, T) - заменить все значения один значением
    - copy(List<T>, List<T>) - копирование (замена) из второго в первый
        - список куда копируется должен быть по размеру не меньше копируемого
    - sort(List<T>, Comparator<T>) - сортировка
    - min | max (Collection<T>)

```
    final List<String> emptyList = Collections.emptyList();
    final List<String> singletonList = Collections.singletonList("Привет, мир!");
    final List<String> nCopiesList = Collections.nCopies(5, "Java");
    
    ArrayList<String> fruits = new ArrayList<>();
    fruits.add("Банан");
    fruits.add("Апельсин");
    fruits.add("Яблоко");
    fruits.add("Груша");

    System.out.println(fruits);

    Collections.sort(fruits, String.CASE_INSENSITIVE_ORDER);

    System.out.println(fruits);
```

## Множество Set

- набор уникальных данных!! но хаотичны, не сохраняет порядок объектов
- проверка на наличие элемента O(1)
- наследуется от Collection
- работает быстрее других, применяется часто
- элементы не упорядочены
- его наследники
    - SortedSet -> NavigableSet -> TreeSet
    - AbstractSet
        - TreeSet
        - HashSet -> LinkedHashSet
- методы
    - add (E e) - возвращает true если сохранился, false - еси существует, при этом не сохранит
    - addAll(Collection <? extends E> c) - добавить список или множество, при этом если хотя бы один содержится вернет
      False
    - contains(Object o) - имеется или нет
    - remove(Object o ) - удаление объекта
    - isEmpty(), size()
- конструкторы
    - public HashSet()
        - пустое множество без параметров
    - public HashSet(Collection<? extends E> c)
        - создает множество из списка или множества
        - останутся только уникальные
    - public HashSet(int initialCapacity, float loadFactor)
        - количество созданных ячеек и коэффициент заполнения
- LinkedHashSet
    - сохраняет порядок добавленных объектов
    - аналогичен LinkedHashMap
    - O(1) - базовые операции
- TreeSet
    - аналогичен TreeMap
    - O(log n) - базовые операции

### Деревья

- способ представить информацию в виде иерархической структуры, где элементы ниже по иерархии, зависят от выше

### String

- строки, созданные не через литерал, не попадут в один и тот же пул, и не будут ==, сравнение new String через
  String.equals()
- методы
    - length(), isEmpty()
    - trim() - удаляет пробелы в начале и в конце (не меняет исходное)
    - toUpperCase(), toLowCase() - изменение регистра
    - charAt(int index) - получить символ по индексу
    - startWish(), endsWish() - начинается, заканчивается
    - contains() - содержит
    - substring(int beginIndex), substring(int beginIndex, int endIndex) - получить подстроку под индексам
        - endIndex - исключается
    - split(String regex) - из строки в массив строк
        - regex - для спец символов необходимо \\ - "\\*"
            - <(>,   <)>, <[>, <{>, <.>, <?>, <*>, <+>,  <|>, <^>, <\>.
- из массива в строку
    - String.join(String delimiter, String... strs)
    ```
        String[] arrayOfPets = new String[]{
                "Кот Батончик",
                "Хомяк Рафаэлка",
                "Попугай Картошка"
        };

        String str = String.join(", ", arrayOfPets);
    ```
    - этим же методом можно создать строку из нескольких строк
        ```
          String cat = "Кот Батончик";
          String pet = "Хомяк Рафаэлка";
          String ara = "Попугай Картошка";

          String str = String.join(", ", cat, pet, ara);  
        ```

- substring - непрерывный набор символов внутри строки
- Замена строк (похоже как в JS)
    - replace(String target, String replacement), replaceFirst(String target, String replacement)
        - replaceFirst заменит только первое вхождение

### StringBuilder

- позволяет менять содержание строки без создания новой
- методы
    - append(String str), append(String str)- вставка в конец
    - toString() - привести к обычной строке
    - методы String - indexOf(), lastIndex(), substring(),replace() - такие же
    - insert(int index, String str) - вставка по индексу
    - deleteCharAt(int index), delete(int startIndexInclusive, int endIndexExclusive)
        - удаление одного или нескольких элементов
    - reverse() - развернуть
    - setLength(int newLength) - обрезка с начала

### Форматирование строк

- похоже как Python Шаблоны
- оформленное отображение строк
- String.format(String format, Object... args) - format - образец, столько же аргументов сколько в образце

```
  String[] colors = new String[]{"красный", "жёлтый", "зелёный"};
  String trafficLight = String.format("Цвета светофора: %s, %s и %s.", colors[0], colors[1], colors[2]);
  System.out.println(trafficLight);

  // либо сразу вывести через printf
  System.out.printf("Цвета светофора: %s, %s и %s.", colors[0], colors[1], colors[2]);
```

- символы преобразования
    - %s — для строк (s — сокращение от string);
        - %S, %b и т.д. — для строк поднять регистр;
    - %d — для целых чисел (d от decimal);
    - %f — для чисел с плавающей точкой (f от float);
    - %b — для булевых значений (b от boolean);
    - %c — для символов (c от char и сharacter).
    - можно привести к типу - System.out.printf("%b", "Hello, Java!"); // получим true
    - \n - перенос строки
- параметры для преобразования
    - %55s - добавит 55 символов перед переменной
    - %-55s - добавит 55 символов после переменной
    - %1.12s - до точки перед, после точки после

### Иерархия исключений

- Все исключения наследуют от одного класса — Throwable
- checked - проверяемые, исключения, обработка которых обязательна и является частью логики приложения
    - Если не настроить обработку проверяемых исключений, то программа не скомпилируется
    - исключение должно быть «отловлено или объявлено выброшенным»
- подклассы
    - Error (unchecked)
        - VirtualMachineError - Базовые ошибки JVM, связанные с тем, что исчерпаны ресурсы или обнаружены повреждения.
        - OutOfMemoryError - Производный класс от VirtualMachineError, который показывает ошибки из-за нехватки памяти.
        - StackOverflowError - Производный класс от VirtualMachineError, показывает переполнение стека из-за того, что
          метод слишком много раз вызывал сам себя.
        - AssertionError - Ошибка утверждения.
        - IOError - Исключение, которое происходит при серьёзных ошибках ввода-вывода.
        - ThreadDeath - Возникает при вызове метода Thread.stop() у потока.
    - Exception (checked)
        - RuntimeException (unchecked)
            - ArithmeticException - Исключения при арифметических операциях, например деление на 0.
            - IllegalArgumentException - Возникает при неверно переданных в метод или конструктор параметрах.
            - IndexOutOfBoundsException - Исключение при выходе за заданный диапазон.
            - NoSuchElementException - Данного элемента больше не существует в перечислении.
            - NullPointerException - Приложение пытается использовать null в том месте, где требуется инициализированный
              объект.
            - UnsupportedOperationException - Операция не поддерживается вызываемым объектом.
            - ClassCastException - Невозможность привести объект к заданному типу.
        - Other Exception (checked)
            - IOException - Это базовый класс проверяемых исключений ввода-вывода.
            - EOFException - Исключение, которое сигнализирует о внезапном достижении конца файла или потока.
            - FileNotFoundException - Файл по указанному пути не существует.
            - FileSystemException - Базовый класс для исключений файловой системы, таких как ошибка доступа, попытка
              создать уже существующий файл или удалить не пустую директорию.
            - MalformedURLException - Неверный синтаксис при создании класса ссылки из строки.
            - SocketException - Ошибки при создании/обрыве соединения по сокету.
            - UnknownHostException - Невозможность определить IP-адрес узла по доменному имени.
            - SQLException - Ошибки при работе с базой данных.
            - TimeoutException - Исключение — происходит у методов, у которых ограничено выполнение по времени.
            - URISyntaxException - Неверный формат универсального идентификатора ресурсов.
- Throwable - ловит все, но не понятно какой тип ошибки

```
        try {
            return new URI(input);
        } catch (URISyntaxException exception) {
            System.out.println("Ошибка: неверный синтаксис URI!");
        } catch (NullPointerException exception) {
            // ловим исключение NullPointerException
            System.out.println("Ошибка: передан неинициализированный объект!");
        }
        return null;
```

- при цепочке Важно соблюдать правильную последовательность
    - сначала исключения в классах-наслдениках
    - потом родительские

```
    // правильно
       try {
            return (String) x;
        } catch (ClassCastException e) {
            System.out.println("Некорректное приведение типов");
        } catch (RuntimeException e) {
            System.out.println("Ошибка во время выполнения");
        } catch (Exception e) {
            System.out.println("Произошла неизвестная ошибка");
        }
    // не правильно
        try {
            return (String) x;
        } catch (Exception e) {
            System.out.println("Произошла неизвестная ошибка");
        } catch (RuntimeException e) {
            System.out.println("Ошибка во время выполнения");
        } catch (ClassCastException e) {
            System.out.println("Некорректное приведение типов");
        }
        return null;
```

- можно объединить типы ошибок, если их обработка, например, одинакова

```
        try {
            new ArrayList<String>().add("1");
        } catch (UnsupportedOperationException | IllegalArgumentException exception) {
            System.out.println("Возникла ошибка, свяжитесь с нами!");
        }
```

- посмотреть стек-трейс исключения - exception.printStackTrace(); // будет выведен стек-трейс ошибки
- сообщение об ошибке коротко - exception.getMessage()
    - лучше не использовать, может быть null
- Throwable.getStackTrace() возвращает массив элементов StackTraceElement
    - можно посмотреть имя класса, имя файла, строка кода

```
catch (ArithmeticException exception) {
  for (StackTraceElement stack : exception.getStackTrace()) {
       System.out.println(String.format("Класс: " + stack.getClassName() + ", " +
                    "метод: " + stack.getMethodName() + ", " +
                    "имя файла: " + stack.getFileName() + ", " +
                    "строка кода: " + stack.getLineNumber()));
}}
```

### Свое исключение

- при создании своего класса Исключений от Exception, Можно переопределить 4 конструктора

```
public class InputException extends Exception {
    public InputException() {
    }

    public InputException(final String message) {
        super(message);
    }

    public InputException(final String message, final Throwable cause) {
        super(message, cause);
    }

    public InputException(final Throwable cause) {
        super(cause);
    }
}

final UserInputException userInputException = new UserInputException("Ошибка ввода!");
        try {
            throw userInputException;

        } catch (Throwable e) {
            System.out.println("eeee " + e.getMessage());
        }

```

- в свой клас можно добавлять свои методы

```
public class Main {
    public static void main(String[] args) {
        printRangeInteger("10", 0, 100);
        printRangeInteger("-10", 0, 100);
        printRangeInteger("110", 0, 100);
        printRangeInteger("abc", 0, 100);
    }

    public static void printRangeInteger(final String inputString, final int from, final int to) {
        try {
            final int input = Integer.parseInt(inputString);
            if (input < from) {
                throw new InputException("Введённое число слишком маленькое!", input);
            }
            if (input > to) {
                throw new InputException("Введённое число слишком большое!", input);
            }
            System.out.println(input);
        } catch (NumberFormatException exception) {
            System.out.println("Ошибка ввода - введено не число!");
        } catch (InputException exception) {
            System.out.println(exception.getDetailMessage());
        }
    }
}

class InputException extends Exception {
    private final int inputValue;

    public InputException(final String message, final int inputValue) {
        super(message);
        this.inputValue = inputValue;
    }

    public String getDetailMessage() {
        return getMessage() + " = " + inputValue;
    }
}
```

#### Слово предупреждение throws

- метод или конструктор может сгенерить исключение
    - public void methodWithException() throws FirstException {}
        - этот метод может сгенерировать исключение FirstException
    - можно несколько throws NumberShouldBePositiveException, IncorrectInputStringException

#### Final - обработка исключений

- если catch не будет, то исключение будет выброшено после final
- return  !!лучше НЕ использовать

```
try {
    // действие, которое может вызвать ошибку
} catch (Exception exception) {
    // действие по обработке исключений
} finally {
    // действие, которое должно вызваться всегда
}
```

### Работа с файлами