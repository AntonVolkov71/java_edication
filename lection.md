### JDK

- Java Development Kit - комплект для разработки
    - компилятор
    - программа для выполнения байт-кода
    - стандартная библиотека Java
    - генератор документации из комментариев к коду
- JDK
    - OpenJDK бесплатный, но доступна последняя сборка без поддержки
    - Oracle - бесплатно, для коммерции платно

### Компилятор javac

- компилятор кода программы в байт-код
- создает файл с расширением .class

### JVM

- Java Virtual Machine
- выполнение построчно байт-кода
- проверяет на наличие ошибок в байт-коде

### Скачать Java

- Разрядность x64: https://corretto.aws/downloads/latest/amazon-corretto-11-x64-windows-jdk.msi.
- Разрядность x86: https://corretto.aws/downloads/latest/amazon-corretto-11-x86-windows-jdk.msi.
- JDK будет находиться здесь:  C:\Program Files\Amazon Corretto\.
- задать переменную JAVA_HOME C:\Program Files\Amazon Corretto\jdk[version]\bin
- добавить путь в PATH C:\Program Files\Amazon Corretto\jdk[version]\bin

- Компиляция
    - один файл # javac -encoding UTF-8 HelloJdk.java
    - несколько файлов # javac -d bin -encoding UTF-8 *.java //bin название папки
- Запуск
    - # java -Dfile.encoding=UTF-8 HelloJdk
    - # java HelloJdk
    - запуск нескольких файлов # java -cp bin test_app.src.service.Main

### JAR

- Java Archive - java архив со всеми файлами, который можно передавать
- внутри JAR есть специальный текстовый файл с описанием структуры архива — файл манифеста MANIFEST.MF
    - генерируется автоматически при создании java-архива и находится по адресу META-INF/MANIFEST.MF
- перевести все файлы в байт-код, далее
    - # jar cfe <имя jar-файла> <имя стартового класса> <список файлов>
    - # jar cfe library.jar Practicum -C bin .
        - # Точка в конце строки указывает на то, что в JAR должны попасть все файлы из папки bin.
    - c (от англ. create, «создавать») указывает на то, что создаётся новый файл;
    - f (от англ. filename, «имя файла») предупреждает, что после него будет написано имя создаваемого jar-файла;
    - e (от англ. entrypoint, «точка входа») указывает на название класса, с которого нужно начать выполнение программы.
- несколько файлов test_app.src/Main.class и другие
    - создать файл MANIFEST.MF в bin - Main-Class: test_app.src.screenshot.Main
    - перейти в папку bin
        - jar cvf test.jar *
- когда есть файл jar можно запустить
    - # java -jar library.jar

### Упаковка в исполняемый файл exe

- Launch4j - использует jar архив

### Поэтапно компиляция

- структура src.screen.Main.java
- создаем MANIFEST.MF можно внутрь пакета для отдельного приложения либо в корень если один сервис
    - Main-Class: src.screen.Main
- из корня компилируем
    - javac -d bin src/screen/Main.java
- создаем jar из корня
    - jar cfm myapp.jar .\src\screen\MANIFEST.MF -C bin .
- запускаем проверяем
    - java -jar myapp.jar

### Примитивы

- Целочисленные
    - byte - 8бит - от -128 до 127
    - short - 16бит - от -32768 до 32767
    - int - 32бит - от -2 147 483 648 до 2 147 483 647 // используется в основном
    - long - 64бит - 18 нулей, обязательно указывать 123123L
- Дробные
    - float - 32бит - от -3.4*10^-38 до 3.4*10^38 // float number = 4.7E-23;
    - double - 64бит от -4.9*10^-324 до 4.9*10^308 // используется в основном
- Символьный
    - char - 16бит - одинарные кавычки
- Логический
    - boolean - true/false

### Значения по умолчанию

- если вывести незаданное поле класса будет ошибка
    - можно ошибиться когда инициализация по умолчанию задала null, а мы не задавали
- Целочисленные - 0
- Дробные - 0.0
- Логические - false
- Ссылочные (классы) - null
- char - \u0000

### Приведение типов

- при передачах аргумента типа, который входит в диапазон типа параметра, происходит автоматическое (неявное) приведение
  типа
    - byte передать в метод, где int - будет приведение
    - short -> long, float -> double
        - Long bigNum = 10L;
        - short smallNum = bigNum.shortValue()
- явное приведение
    - нельзя тип с большим диапазоном привести к меньшему - int -> byte Ошибка
    - можно самостоятельно привести (byte)integerValue - явное приведение
    - НО! если при явном приведении, значение больше чем диапазон меньшего, будет непредсказуемый результат
    - дробное можно к целочисленному, останется только целая часть

### Классы обертки

- "старшие братья" примитивов
- хранят ссылку, не имеют фиксированного размера, возвращают null, имеют свои методы
    - byte - Byte
    - short - Short
    - int - Integer
    - long - Long
    - float - Float
    - double - Double
    - char - Character
    - boolean - Boolean
- упаковка примитива автоматическая - boxing

```
  int primitive = 7;
  Integer wrapper = primitive;
  
  byte primitive = 3;
  method(primitive);
  
  ...    methjd(Byte num){}
    
    int a = 15;
    int b = 3;
    int c = -7;
    Integer[] numbers = new Integer[3];
    
    numbers[0] = a;
    numbers[1] = b;
    numbers[2] = c; 
    
```

- обратная распаковка типа - unboxing
- но если в классе обертке null, распаковка даст ошибку

```
  Boolean wrapper = true; // упаковали значение в класс-обёртку Boolean
  boolean primitive = wrapper; // распаковали обратно в примитив boolean

    // ошибка
    Float wrapper = null;
    float primitive = wrapper;
    System.out.println(primitive);
```

### Парсинг

- все, кроме Character, имеют метод, позволяющий преобразовывать строки в свой тип
- Числовые (кроме Byte, Short для них делать приведение типа) обертки имеют встроенные методы типа max, min, sum,

### Память Java

- СТЕК
    - жестко выделенная память
    - переменные примитивов хранятся в стеке
    - когда начинает выполнятся Метод, в стеке создается новый блок - фрейм стека, все переменные внутри стека, будут
      созданы
      внутри этого блока стека. При завершении метода, все переменные не доступны
    - поэтому когда мы передаем примитивы как аргументы они копируются в блок стека, все изменения переменных остается
      внутри блока
- КУЧА
    - динамическая память
    - хранятся объекты
    - классы передаются по ссылке, то есть при изменении внутри метода изменится значения в самом классе

### Приведение в арифметических выражениях

- если в double сохранить int1 / int2 - будет х.0, дробная часть будет 0!!
    - если хотя бы один операнд будет double, будет автоматическое приведение к double деления(то же самое, при
      сложении, вычитании и т.д.)

### Порядок вычислений

- Первыми отработают операторы префиксного инкремента и декремента — ++a и --a;
- Затем — операторы умножения, деления и остатка от деления: *, / и %;
- Третьи на очереди — операторы сложения и вычитания + и -;
- Последними выполняются операции с постфиксным инкрементом и декрементом: a++ и a--.

### Порядок логических операций

- Сначала всегда выполняется отрицание !.
- Логическое умножение предшествует сложению — поэтому логическое И && в приоритете.
- Логическое ИЛИ || при наличии других операций выполняется последним.

### Пакеты

- по сути это папка - namespace - пространство имен с файлами классов
- можно импортировать весь пакет, когда много классов import java.util.*;

### Списки & массивы

- java.util.ArrayList - список, хранит только Классы
- ArrayList<String> names = new ArrayList<>();
    - add, get - по несуществующему индексу вызовет исключение
    - add(E e) - добавить элемент, можно передать примитив (упаковка автоматическая)
        - add( int index, E e ) - если использовать index можно вставить в определенное место
    - get(int index) - получить по индексу
    - size() - размер
    - remove(int index)(Object o) - удаление по индексу либо по значению
    - clear() - очистить весь список
    - isEmpty() - пустой или нет
    - contains(E e) - возвращает Boolean, проверяет содержит или нет значение
- массив может хранить примитивы, ссылочные типы
    - length - всегда одно и тоже, так как задается длина при объявлении

### Хеш Таблицы

- java.util.HashMap - вместо индекса используется ключ
- HashMap<String, Integer> ages = new HashMap<>();
    - не может быть два одинаковых ключа
    - ключ может быть: число, символ, строка, объект
    - если нет ключа вернёт Null
    - put(K key, V value) - вставка
    - values() - получение массива значений
    - keySet() - получение массива ключей
    - remove(Object key) - удаление по ключу
    - clear() - полностью очистка
    - containsKey(Object key) - проверка по ключу, вернет Boolean
    - containsValue(Object value) - проверка по значению, вернет Boolean

### Object

- методы
    - для генерации используем Generate-> equals hashCode -> next тех полей которые нужно
    - для генерации toString используем Generate-> etoString -> тех полей которые нужно
    - equals(Object) - возвращает результат проверки объектов на равенство, Используется
        - == - не подходит, так как используется только для примитивов,
        - для корректного сравнения нужно переопределить equals()
        - Необходимо переопределять!!!
        ```
          // по умолчанию
          public boolean equals(Object obj) {
            return (this == obj);
          }
      
          // корректное переопределение 
          class Book {
            public String title;
            public String author;
            public int pagesNumber;
          
            public Book(String title, String author, int pagesNumber) {
            this.title = title;
            this.author = author;
            this.pagesNumber = pagesNumber;
            }
          
            @Override
            public boolean equals(Object obj) {
            if (this == obj) return true; // проверяем адреса объектов
            if (obj == null) return false; // проверяем ссылку на null
            if (this.getClass() != obj.getClass()) return false; // сравниваем классы объектов
          
                  Book otherBook = (Book) obj; // привели второй объект к классу Book
          
                  return Objects.equals(title, otherBook.title) && // проверяем все поля
                          Objects.equals(author, otherBook.author) && // нужно логическое «и»
                          (pagesNumber == otherBook.pagesNumber); // примитивы сравниваем через ==
          
            }
          }
        ```
    - hashCode() - возвращает хеш-код объекта, Используется
        - Необходимо переопределять!!!
        - Базовая реализация метода hashCode() стремится создать уникальный хеш для каждого объекта, в том числе для
          идентичных
        - У всех стандартных ссылочных типов данных в Java (String, Integer, Double и т. д.) методы equals(Object) и
          hashCode() уже корректно переопределены
          ```
               @Override
               public int hashCode() {
                    int hash = 17;
                    if (firstName != null) {
                    // вычисляем хеш первого поля и добавляем к нему начальное значение
                      hash = hash + firstName.hashCode();
                    }
                    hash = hash * 31; // умножаем промежуточный результат на простое число

                    if (lastName != null) {
                    // вычисляем хеш второго поля и добавляем его к общему результату
                    hash = hash + lastName.hashCode();
                      }
                    return hash; // возвращаем итоговый хеш
               }
          ```
        - Три правила переопределения (контракт)
            - Если при сравнении методом equals(Object) объекты оказались равны, то hashCode() должен возвращать у
              каждого из них одно и то же число
            - метод hashCode() должен возвращать одно и то же целое число до тех пор, пока значения полей, используемых
              в методе equals(Object) того же класса, остаются прежними
            - Нужно стремиться к тому, чтобы у объектов, которые не равны при сравнении equals(Object), были разные
              хеш-коды, но учитывать, что они могут совпасть.
                - Поэтому, если у двух объектов одинаковые хеш-коды, нельзя утверждать, что объекты равны. Точный
                  результат покажет только метод equals(Object).
    - getClass() - возвращает класс объекта
    - toString() - строковое представление объекта, Используется
        - Необходимо переопределять!!!
        - только чтение, Не менять состояние объекта
        - В реализацию toString() стоит включать только те поля, которые содержат ключевую или определяющую информацию.
        - Статические или вспомогательные поля можно опустить.
        - Некоторые поля могут содержать объёмные данные. Нет практического смысла в том, чтобы выводить их полное или
          даже сокращённое содержание.
        - Можно отобразить их длину
        - В отдельном форматировании могут также нуждаться такие данные, как даты
        - println(Object) - выведет toString класса
        - соблюдать единй формат
            ```
              @Override // переопределяем toString
              public String toString() {
                return "Person{" + // имя класса
                       "firstName='" + firstName + '\'' + // поле1=значение1
                       ", lastName='" + lastName + // поле2=значение2
                       '}';
              }
            ```
    - clone() - копия объекта
    - wait(lon timeoutMillis) - освобождает монитор и переводит вызывающий поток в ожидание (параметр timeout не
      обязательный)
    - notify(), notifyAll() - возобновляет работу потока (потоков)

### Code style

- в стандарте оформления кода формулируются соглашения по следующим пунктам:
- максимальная длина строки,
- отступы,
- табуляция,
- пустые строки,
- скобки,
- пробелы внутри выражений и инструкций,
- стиль комментариев,
- принципы именования классов, переменных, методов и проч.
- Длина строки в коде должна быть не более 120 символов.
    - Перенос строки должен выполняться после запятой.
    -
        + / : . - на новую строку
  ```
  Плохо
    int period, action; 
    // На одной строке объявлено несколько переменных.
  
  Хорошо
    int period;
    int action;
    // Каждая переменная объявлена на отдельной строке
  ```

### Live Templates

- psvm - метод main
- sout — разворачивается в инструкцию System.out.println();.
- soutm — выводит в консоль имя текущего класса и метода. Например, System.out.println("LiveTemplates.main");.
- soutp — выводит в консоль аргументы метода. Например, System.out.println("args = " + Arrays.deepToString(args));.
- soutv — эта команда похожа на предыдущую, она выводит в консоль значение переменной в формате System.out.println("
  имяПеременной = " + имяПеременной);.
- ifn — создаст конструкцию if для поверки переменной на равенство null
- fori — создаст заготовку для цикла for с переменной i в качестве счётчика
- iter — создаст заготовку для цикла по массиву или списку.

### README.md

- Название проекта и его краткое описание: кем он создан, для чего, какие решает задачи и какие закрывает проблемы.
- Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
- Документация проекта — инструкция о том, как его запустить или протестировать. Здесь же можно найти системные
  требования: версия языка, необходимые расширения.
- Планы проекта, если они есть.

### Модификаторы доступа