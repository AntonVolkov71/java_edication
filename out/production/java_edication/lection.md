### JDK
- Java Development Kit - комплект для разработки
  - компилятор
  - программа для выполнения байт-кода
  - стандартная библиотека Java
  - генератор документации из комментариев к коду
- JDK
  - OpenJDK бесплатный, но доступна последняя сборка без поддержки
  - Oracle - бесплатно, для коммерции платно

### Компилятор javac
- компилятор кода программы в байт-код
- создает файл с расширением .class

### JVM
- Java Virtual Machine
- выполнение построчно байт-кода
- проверяет на наличие ошибок в байт-коде

### Скачать Java
- Разрядность x64: https://corretto.aws/downloads/latest/amazon-corretto-11-x64-windows-jdk.msi.
- Разрядность x86: https://corretto.aws/downloads/latest/amazon-corretto-11-x86-windows-jdk.msi.
- JDK будет находиться здесь:  C:\Program Files\Amazon Corretto\.
- задать переменную JAVA_HOME C:\Program Files\Amazon Corretto\jdk[version]\bin
- добавить путь в PATH C:\Program Files\Amazon Corretto\jdk[version]\bin

- Компиляция
  - один файл # javac -encoding UTF-8 HelloJdk.java
  - несколько файлов # javac -d bin -encoding UTF-8 *.java //bin название папки
- Запуск
  - # java -Dfile.encoding=UTF-8 HelloJdk
  - # java HelloJdk
  - запуск нескольких файлов # java -cp bin test_app.src.service.Main

### JAR
- Java Archive - java архив со всеми файлами, который можно передавать
- внутри JAR есть специальный текстовый файл с описанием структуры архива — файл манифеста MANIFEST.MF
  - генерируется автоматически при создании java-архива и находится по адресу META-INF/MANIFEST.MF
- перевести все файлы в байт-код, далее
  - # jar cfe <имя jar-файла> <имя стартового класса> <список файлов>
  - # jar cfe library.jar Practicum -C bin .
     - # Точка в конце строки указывает на то, что в JAR должны попасть все файлы из папки bin.
  - c (от англ. create, «создавать») указывает на то, что создаётся новый файл;
  - f (от англ. filename, «имя файла») предупреждает, что после него будет написано имя создаваемого jar-файла;
  - e (от англ. entrypoint, «точка входа») указывает на название класса, с которого нужно начать выполнение программы.
- несколько файлов test_app.src/Main.class и другие
  - создать файл MANIFEST.MF в bin - Main-Class: test_app.src.screenshot.Main
  - перейти в папку bin
    - jar cvf test.jar *
- когда есть файл jar можно запустить
  - # java -jar library.jar

### Упаковка в исполняемый файл exe
- Launch4j - использует jar архив

### Поэтапно компиляция
- структура src.screen.Main.java
- создаем MANIFEST.MF можно внутрь пакета для отдельного приложения либо в корень если один сервис
  - Main-Class: src.screen.Main
- из корня компилируем 
  - javac -d bin src/screen/Main.java
- создаем jar из корня
  - jar cfm myapp.jar .\src\screen\MANIFEST.MF -C bin .
- запускаем проверяем
  - java -jar myapp.jar

### Примитивы
- Целочисленные
  - byte - 8бит - от -128 до 127
  - short - 16бит - от -32768 до 32767
  - int - 32бит - от -2 147 483 648 до 2 147 483 647 // используется в основном
  - long - 64бит - 18 нулей, обязательно указывать 123123L
- Дробные
  - float - 32бит - от -3.4*10^-38 до 3.4*10^38              //  float number = 4.7E-23;
  - double - 64бит от -4.9*10^-324 до 4.9*10^308             // используется в основном
- Символьный
  - char - 16бит - одинарные кавычки
- Логический
  - boolean - true/false

### Значения по умолчанию
- если вывести незаданное поле класса будет ошибка
  - можно ошибиться когда инициализация по умолчанию задала null, а мы не задавали
- Целочисленные - 0
- Дробные - 0.0
- Логические - false
- Ссылочные (классы) - null
- char - \u0000

### Приведение типов
- при передачах аргумента типа, который входит в диапазон типа параметра, происходит автоматическое (неявное) приведение типа
  - byte передать в метод, где int - будет приведение
  - short -> long, float -> double
    - Long bigNum = 10L;
    - short smallNum = bigNum.shortValue()
- явное приведение
  - нельзя тип с большим диапазоном привести к меньшему - int -> byte Ошибка
  - можно самостоятельно привести (byte)integerValue - явное приведение
  - НО! если при явном приведении, значение больше чем диапазон меньшего, будет непредсказуемый результат
  - дробное можно к целочисленному, останется только целая часть

### Классы обертки
- "старшие братья" примитивов
- хранят ссылку, не имеют фиксированного размера, возвращают null, имеют свои методы
  - byte - Byte
  - short - Short
  - int - Integer
  - long - Long
  - float - Float
  - double - Double
  - char - Character
  - boolean - Boolean
- упаковка примитива автоматическая - boxing
```
  int primitive = 7;
  Integer wrapper = primitive;
  
  byte primitive = 3;
  method(primitive);
  
  ...    methjd(Byte num){}
    
    int a = 15;
    int b = 3;
    int c = -7;
    Integer[] numbers = new Integer[3];
    
    numbers[0] = a;
    numbers[1] = b;
    numbers[2] = c; 
    
```
- обратная распаковка типа - unboxing
- но если в классе обертке null, распаковка даст ошибку
```
  Boolean wrapper = true; // упаковали значение в класс-обёртку Boolean
  boolean primitive = wrapper; // распаковали обратно в примитив boolean

    // ошибка
    Float wrapper = null;
    float primitive = wrapper;
    System.out.println(primitive);
```

### Парсинг
- все, кроме Character, имеют метод, позволяющий преобразовывать строки в свой тип
- Числовые (кроме Byte, Short для них делать приведение типа) обертки имеют встроенные методы типа max, min, sum,

### Память Java
- СТЕК
  - жестко выделенная память
  - переменные примитивов хранятся в стеке
  - когда начинает выполнятся Метод, в стеке создается новый блок - фрейм стека, все переменные внутри стека, будут созданы
    внутри этого блока стека. При завершении метода, все переменные не доступны
  - поэтому когда мы передаем примитивы как аргументы они копируются в блок стека, все изменения переменных остается внутри блока
- КУЧА
  - динамическая память 
  - хранятся объекты
  - классы передаются по ссылке, то есть при изменении внутри метода изменится значения в самом классе

### Приведение в арифметических выражениях
- если в double сохранить int1 / int2 - будет х.0, дробная часть будет 0!!
  - если хотя бы один операнд будет double, будет автоматическое приведение к double деления(то же самое, при сложении, вычитании и т.д.) 

### Порядок вычислений
- Первыми отработают операторы префиксного инкремента и декремента — ++a и --a;
- Затем — операторы умножения, деления и остатка от деления: *, / и %;
- Третьи на очереди — операторы сложения и вычитания + и -;
- Последними выполняются операции с постфиксным инкрементом и декрементом: a++ и a--.

### Порядок логических операций
- Сначала всегда выполняется отрицание !.
- Логическое умножение предшествует сложению — поэтому логическое И && в приоритете.
- Логическое ИЛИ || при наличии других операций выполняется последним.

### Пакеты
- по сути это папка - namespace - пространство имен с файлами классов
- можно импортировать весь пакет, когда много классов import java.util.*;

### Списки & массивы
- java.util.ArrayList - список, хранит только Классы
- ArrayList<String> names = new ArrayList<>();
  - add, get - по несуществующему индексу вызовет исключение
  - add(E e) - добавить элемент, можно передать примитив (упаковка автоматическая)
    - add( int index, E e ) - если использовать index можно вставить в определенное место
  - get(int index) - получить по индексу
  - size() - размер
  - remove(int index)(Object o) - удаление по индексу либо по значению 
  - clear() - очистить весь список
  - isEmpty() - пустой или нет
  - contains(E e) - возвращает Boolean, проверяет содержит или нет значение
- массив может хранить примитивы, ссылочные типы
  - length - всегда одно и тоже, так как задается длина при объявлении

### Хеш Таблицы
- java.util.HashMap - вместо индекса используется ключ
- HashMap<String, Integer> ages = new HashMap<>();
  - не может быть два одинаковых ключа
  - ключ может быть: число, символ, строка, объект
  - если нет ключа вернёт Null
  - put(K key, V value) - вставка
  - values() - получение массива значений
  - keySet() - получение массива ключей

_МОДИФИКАТОРЫ ДОСТУПА И ИМЕНА ОБРАТНЫЕ ПАКЕТОВ_